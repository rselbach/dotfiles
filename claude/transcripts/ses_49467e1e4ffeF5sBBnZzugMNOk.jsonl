{"type":"user","timestamp":"2025-12-29T19:31:29.960Z","content":"This directory has an LRU implementation I created for a project. I want you to review it looking for bugs."}
{"type":"tool_use","timestamp":"2025-12-29T19:31:41.467Z","tool_name":"read","tool_input":{"filePath":"/Users/rselbach/devel/lru/lru.go"}}
{"type":"tool_result","timestamp":"2025-12-29T19:31:41.478Z","tool_name":"read","tool_input":{"filePath":"/Users/rselbach/devel/lru/lru.go"},"tool_output":{"preview":"// Package lru provides a generic, thread-safe LRU cache implementation.\npackage lru\n\nimport (\n\t\"container/list\"\n\t\"errors\"\n\t\"sync\"\n)\n\n// Cache errors\nvar (\n\tErrKeyNotFound = errors.New(\"key not found in cache\")\n\tErrNilValue    = errors.New(\"nil value not allowed\")\n)\n\n// OnEvictFunc is a function that is called when an entry is evicted from the cache.\ntype OnEvictFunc[K comparable, V any] func(key K, value V)\n\n// Cache represents a thread-safe, fixed-size LRU cache.\ntype Cache[K comparable, V any] struct {"}}
{"type":"tool_use","timestamp":"2025-12-29T19:31:42.212Z","tool_name":"read","tool_input":{"filePath":"/Users/rselbach/devel/lru/expirable.go"}}
{"type":"tool_result","timestamp":"2025-12-29T19:31:42.216Z","tool_name":"read","tool_input":{"filePath":"/Users/rselbach/devel/lru/expirable.go"},"tool_output":{"preview":"// Package lru provides a generic, thread-safe LRU cache implementation.\npackage lru\n\nimport (\n\t\"container/list\"\n\t\"errors\"\n\t\"sync\"\n\t\"time\"\n)\n\n// expirableEntry extends cacheEntry with an expiry time.\ntype expirableEntry[K comparable, V any] struct {\n\tkey    K\n\tval    V\n\texpiry time.Time\n}\n\n// Expirable represents a thread-safe, fixed-size LRU cache with expiry functionality.\ntype Expirable[K comparable, V any] struct {\n\tcapacity int"}}
{"type":"tool_use","timestamp":"2025-12-29T19:31:45.541Z","tool_name":"background_task","tool_input":{"description":"Find concurrency patterns in LRU","prompt":"Explore this Go LRU cache implementation looking for:\n1. Concurrency patterns - how is thread safety handled?\n2. Lock usage patterns - are there any potential deadlocks or race conditions?\n3. Any code paths where locks might not be properly held\n\nFocus on lru.go and expirable.go. Report specific line numbers and code snippets for any concerns.","agent":"explore"}}
{"type":"tool_result","timestamp":"2025-12-29T19:31:45.545Z","tool_name":"background_task","tool_input":{"description":"Find concurrency patterns in LRU","prompt":"Explore this Go LRU cache implementation looking for:\n1. Concurrency patterns - how is thread safety handled?\n2. Lock usage patterns - are there any potential deadlocks or race conditions?\n3. Any code paths where locks might not be properly held\n\nFocus on lru.go and expirable.go. Report specific line numbers and code snippets for any concerns.","agent":"explore"},"tool_output":{"output":"Background task launched successfully.\n\nTask ID: bg_eb95a3ff\nSession ID: ses_49467a4f9ffesYB7YEY7pYgbg8\nDescription: Find concurrency patterns in LRU\nAgent: explore\nStatus: running\n\nThe system will notify you when the task completes.\nUse `background_output` tool with task_id=\"bg_eb95a3ff\" to check progress:\n- block=false (default): Check status immediately - returns full status info\n- block=true: Wait for completion (rarely needed since system notifies)"}}
{"type":"tool_use","timestamp":"2025-12-29T19:31:47.945Z","tool_name":"background_task","tool_input":{"description":"Find edge cases in LRU logic","prompt":"Explore this Go LRU cache implementation looking for edge cases and potential bugs:\n1. What happens with zero/negative capacity?\n2. TTL expiration edge cases in expirable.go\n3. Memory leaks (items not being properly cleaned up)\n4. Off-by-one errors in size tracking\n\nFocus on lru.go and expirable.go. Report specific line numbers and code snippets for any concerns.","agent":"explore"}}
{"type":"tool_result","timestamp":"2025-12-29T19:31:47.948Z","tool_name":"background_task","tool_input":{"description":"Find edge cases in LRU logic","prompt":"Explore this Go LRU cache implementation looking for edge cases and potential bugs:\n1. What happens with zero/negative capacity?\n2. TTL expiration edge cases in expirable.go\n3. Memory leaks (items not being properly cleaned up)\n4. Off-by-one errors in size tracking\n\nFocus on lru.go and expirable.go. Report specific line numbers and code snippets for any concerns.","agent":"explore"},"tool_output":{"output":"Background task launched successfully.\n\nTask ID: bg_360e41f9\nSession ID: ses_494679b95ffe0Y91VIRUwZ9wUy\nDescription: Find edge cases in LRU logic\nAgent: explore\nStatus: running\n\nThe system will notify you when the task completes.\nUse `background_output` tool with task_id=\"bg_360e41f9\" to check progress:\n- block=false (default): Check status immediately - returns full status info\n- block=true: Wait for completion (rarely needed since system notifies)"}}
{"type":"tool_use","timestamp":"2025-12-29T19:31:56.066Z","tool_name":"read","tool_input":{"filePath":"/Users/rselbach/devel/lru/lru_test.go"}}
{"type":"tool_result","timestamp":"2025-12-29T19:31:56.067Z","tool_name":"read","tool_input":{"filePath":"/Users/rselbach/devel/lru/lru_test.go"},"tool_output":{"preview":"package lru\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestCache_New(t *testing.T) {\n\ttests := map[string]struct {\n\t\tcapacity    int\n\t\texpectError bool\n\t}{\n\t\t\"valid capacity\": {\n\t\t\tcapacity:    5,\n\t\t\texpectError: false,\n\t\t},\n\t\t\"zero capacity\": {\n\t\t\tcapacity:    0,"}}
{"type":"tool_use","timestamp":"2025-12-29T19:31:56.586Z","tool_name":"read","tool_input":{"filePath":"/Users/rselbach/devel/lru/expirable_test.go"}}
{"type":"tool_result","timestamp":"2025-12-29T19:31:56.587Z","tool_name":"read","tool_input":{"filePath":"/Users/rselbach/devel/lru/expirable_test.go"},"tool_output":{"preview":"package lru\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\n// mockTime is a helper for testing time-based functionality.\ntype mockTime struct {\n\tcurrentTime time.Time\n}\n\nfunc newMockTime() *mockTime {\n\treturn &mockTime{\n\t\tcurrentTime: time.Now(),\n\t}\n}"}}
{"type":"tool_use","timestamp":"2025-12-29T19:32:04.701Z","tool_name":"read","tool_input":{"filePath":"/Users/rselbach/devel/lru/callbacks_test.go"}}
{"type":"tool_result","timestamp":"2025-12-29T19:32:04.702Z","tool_name":"read","tool_input":{"filePath":"/Users/rselbach/devel/lru/callbacks_test.go"},"tool_output":{"preview":"package lru\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestCache_OnEvict(t *testing.T) {\n\tr := require.New(t)\n\tcache := MustNew[string, int](3)\n\n\tevicted := make(map[string]int)\n\tcache.OnEvict(func(key string, value int) {\n\t\tevicted[key] = value\n\t})\n\n\t// Add items to the cache\n\tcache.Set(\"a\", 1)"}}
{"type":"tool_use","timestamp":"2025-12-29T19:32:05.739Z","tool_name":"background_output","tool_input":{"task_id":"bg_eb95a3ff"}}
{"type":"tool_result","timestamp":"2025-12-29T19:32:05.742Z","tool_name":"background_output","tool_input":{"task_id":"bg_eb95a3ff"},"tool_output":{"output":"# Task Status\n\n| Field | Value |\n|-------|-------|\n| Task ID | `bg_eb95a3ff` |\n| Description | Find concurrency patterns in LRU |\n| Agent | explore |\n| Status | **running** |\n| Duration | 20s |\n| Session ID | `ses_49467a4f9ffesYB7YEY7pYgbg8` |\n| Last tool | grep_app_searchGitHub |\n\n\n> **Note**: No need to wait explicitly - the system will notify you when this task completes.\n## Original Prompt\n\n```\nExplore this Go LRU cache implementation looking for:\n1. Concurrency patterns - how is thread safety handled?\n2. Lock usage patterns - are there any potential deadlocks or race conditions?\n3. Any code paths where locks might not be properly held\n\nFocus on lru.go and expirable.go. Report specific line numbers and code snippets for any concerns.\n```"}}
{"type":"tool_use","timestamp":"2025-12-29T19:32:06.217Z","tool_name":"background_output","tool_input":{"task_id":"bg_360e41f9"}}
{"type":"tool_result","timestamp":"2025-12-29T19:32:06.217Z","tool_name":"background_output","tool_input":{"task_id":"bg_360e41f9"},"tool_output":{"output":"# Task Status\n\n| Field | Value |\n|-------|-------|\n| Task ID | `bg_360e41f9` |\n| Description | Find edge cases in LRU logic |\n| Agent | explore |\n| Status | **running** |\n| Duration | 18s |\n| Session ID | `ses_494679b95ffe0Y91VIRUwZ9wUy` |\n| Last tool | read |\n\n\n> **Note**: No need to wait explicitly - the system will notify you when this task completes.\n## Original Prompt\n\n```\nExplore this Go LRU cache implementation looking for edge cases and potential bugs:\n1. What happens with zero/negative capacity?\n2. TTL expiration edge cases in expirable.go\n3. Memory leaks (items not being properly cleaned up)\n4. Off-by-one errors in size tracking\n\nFocus on lru.go and expirable.go. Report specific line numbers and code snippets for any concerns.\n```"}}
{"type":"user","timestamp":"2025-12-29T19:32:19.035Z","content":"[BACKGROUND TASK COMPLETED] Task \"Find edge cases in LRU logic\" finished in 30s. Use background_output with task_id=\"bg_360e41f9\" to get results."}
{"type":"user","timestamp":"2025-12-29T19:32:19.630Z","content":"[BACKGROUND TASK COMPLETED] Task \"Find concurrency patterns in LRU\" finished in 33s. Use background_output with task_id=\"bg_eb95a3ff\" to get results."}
{"type":"tool_use","timestamp":"2025-12-29T19:32:42.367Z","tool_name":"bash","tool_input":{"command":"cd /Users/rselbach/devel/lru && go test -race -count=1 ./... 2>&1","description":"Run tests with race detector"}}
{"type":"tool_result","timestamp":"2025-12-29T19:32:44.988Z","tool_name":"bash","tool_input":{"command":"cd /Users/rselbach/devel/lru && go test -race -count=1 ./... 2>&1","description":"Run tests with race detector","env":{"CI":"true","DEBIAN_FRONTEND":"noninteractive","GIT_TERMINAL_PROMPT":"0","GCM_INTERACTIVE":"never","HOMEBREW_NO_AUTO_UPDATE":"1","GIT_EDITOR":"true","EDITOR":"true","VISUAL":"true","GIT_SEQUENCE_EDITOR":"true","GIT_PAGER":"cat","PAGER":"cat","npm_config_yes":"true","PIP_NO_INPUT":"1","YARN_ENABLE_IMMUTABLE_INSTALLS":"false"}},"tool_output":{"output":"ok  \tgithub.com/rselbach/lru\t2.354s\n","exit":0,"description":"Run tests with race detector"}}
{"type":"tool_use","timestamp":"2025-12-29T19:32:53.484Z","tool_name":"background_output","tool_input":{"task_id":"bg_360e41f9"}}
{"type":"tool_result","timestamp":"2025-12-29T19:32:53.491Z","tool_name":"background_output","tool_input":{"task_id":"bg_360e41f9"},"tool_output":{"output":"Task Result\n\nTask ID: bg_360e41f9\nDescription: Find edge cases in LRU logic\nDuration: 30s\nSession ID: ses_494679b95ffe0Y91VIRUwZ9wUy\n\n---\n\n<results>\n<files>\n- /Users/rselbach/devel/lru/expirable.go — Contains TTL expiration logic with potential memory leak from uncleared expired entries\n- /Users/rselbach/devel/lru/lru.go — Contains capacity validation and size tracking logic\n</files>\n\n<answer>\nThe LRU cache implementation handles zero/negative capacity correctly with proper validation in both `New()` and `NewExpirable()` functions. TTL expiration edge cases are generally well-handled, with expired items being removed on access and write operations. Size tracking appears accurate with no off-by-one errors found.\n\nHowever, there is a significant memory leak issue in the expirable cache: expired items remain in memory until they are either accessed (which removes them) or until a write operation triggers cleanup. This means if you have expired items that are never accessed again, they will accumulate in the cache's internal data structures indefinitely, consuming memory without being counted in `Len()` or appearing in `Keys()`.\n\nThe main concern is in `expirable.go` where expired entries persist in the `items` map and `lruList` until explicitly cleaned up, creating a potential memory leak in scenarios with low read/write activity on expired keys.</answer>\n\n<next_steps>\nReview the automatic cleanup strategy - consider adding background cleanup or more aggressive removal of expired items during read operations. The current implementation only cleans expired items during write operations or when expired items are accessed.</next_steps>\n</results>"}}
{"type":"tool_use","timestamp":"2025-12-29T19:32:53.998Z","tool_name":"background_output","tool_input":{"task_id":"bg_eb95a3ff"}}
{"type":"tool_result","timestamp":"2025-12-29T19:32:54.000Z","tool_name":"background_output","tool_input":{"task_id":"bg_eb95a3ff"},"tool_output":{"output":"Task Result\n\nTask ID: bg_eb95a3ff\nDescription: Find concurrency patterns in LRU\nDuration: 33s\nSession ID: ses_49467a4f9ffesYB7YEY7pYgbg8\n\n---\n\n<results>\n<files>\n- /Users/rselbach/devel/lru/lru.go — Thread-safe LRU cache using sync.RWMutex; Get uses write lock due to LRU list modification\n- /Users/rselbach/devel/lru/expirable.go — Thread-safe expirable LRU cache using sync.RWMutex; includes expiry checks with proper lock handling\n</files>\n\n<answer>\nThe LRU cache implementation is thread-safe with no deadlocks or race conditions found. Both `lru.go` and `expirable.go` use `sync.RWMutex` consistently:\n\n**Concurrency Patterns:**\n- Read operations (Len, Contains, Keys) use `RLock()` for concurrent access\n- Write operations (Set, Remove, Clear, OnEvict) use `Lock()` for exclusive access\n- Get operations use `Lock()` because they modify the LRU list order (MoveToFront)\n\n**Lock Usage Analysis:**\n- All lock acquisitions are properly paired with unlocks using defer\n- No inconsistent lock ordering that could cause deadlocks\n- GetOrSet avoids deadlocks by computing values outside locks, with double-check pattern to handle concurrent additions\n\n**Potential Performance Note:**\nGet operations cannot run concurrently due to LRU list modifications requiring write locks. This is correct for LRU semantics but may impact read-heavy workloads.\n\n**Expiry Handling in expirable.go:**\n- Expiry checks are performed under lock\n- Expired items are removed immediately on access\n- Callbacks are invoked outside locks to prevent deadlocks\n\nNo race conditions or improper lock holding detected. The implementation correctly handles concurrent access patterns.</answer>\n\n<next_steps>\nAnalysis complete - no concurrency issues found. The cache is thread-safe with proper lock usage patterns.</next_steps>\n</results>"}}
{"type":"tool_use","timestamp":"2025-12-29T19:33:20.318Z","tool_name":"background_cancel","tool_input":{"all":true}}
{"type":"tool_result","timestamp":"2025-12-29T19:33:20.320Z","tool_name":"background_cancel","tool_input":{"all":true},"tool_output":{"output":"✅ No running background tasks to cancel."}}
{"type":"user","timestamp":"2025-12-29T19:37:02.986Z","content":"I think the behaviour of Clear() is good as is. It's not really an eviction as it is a total cache clear. Should document this in godoc. \n\nAs for the memory leak, I'm not sure I follow how the memory grows unbouded on a read-heavy workload. Isnt the only way to add items via Set() in which case we do evict? I may be missing something"}
{"type":"user","timestamp":"2025-12-29T19:40:23.125Z","content":"as for the SetTimeNowFunc, I see your point, but would it be best to add a nil check on the invocations of timeNow() instead, so that if we pass nil to SetTimeNowFunc we're basically saying there is no timeNow. Actually, I am trying to remember why I even have this function. I don't remember why I added that"}
{"type":"user","timestamp":"2025-12-29T19:41:23.447Z","content":"I agree with you, option 1 it is"}
{"type":"tool_use","timestamp":"2025-12-29T19:41:34.295Z","tool_name":"edit","tool_input":{"filePath":"/Users/rselbach/devel/lru/expirable.go","oldString":"// SetTimeNowFunc allows replacing the function used to get the current time.\n// This is primarily used for testing.\nfunc (c *Expirable[K, V]) SetTimeNowFunc(f func() time.Time) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tc.timeNow = f\n}","newString":""}}
{"type":"tool_result","timestamp":"2025-12-29T19:41:34.467Z","tool_name":"edit","tool_input":{"filePath":"/Users/rselbach/devel/lru/expirable.go","oldString":"// SetTimeNowFunc allows replacing the function used to get the current time.\n// This is primarily used for testing.\nfunc (c *Expirable[K, V]) SetTimeNowFunc(f func() time.Time) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tc.timeNow = f\n}","newString":""},"tool_output":{"diagnostics":{"/Users/rselbach/devel/lru/lru.go":[],"/Users/rselbach/devel/lru/expirable.go":[],"/Users/rselbach/devel/lru/lru_test.go":[],"/Users/rselbach/devel/lru/expirable_test.go":[],"/Users/rselbach/devel/lru/callbacks_test.go":[]},"diff":"Index: /Users/rselbach/devel/lru/expirable.go\n===================================================================\n--- /Users/rselbach/devel/lru/expirable.go\n+++ /Users/rselbach/devel/lru/expirable.go\n@@ -391,17 +391,8 @@\n \tc.ttl = ttl\n \treturn nil\n }\n \n-// SetTimeNowFunc allows replacing the function used to get the current time.\n-// This is primarily used for testing.\n-func (c *Expirable[K, V]) SetTimeNowFunc(f func() time.Time) {\n-\tc.mu.Lock()\n-\tdefer c.mu.Unlock()\n-\n-\tc.timeNow = f\n-}\n-\n // OnEvict sets a callback function that will be called when an entry is evicted from the cache.\n // The callback will receive the key and value of the evicted entry.\n // This includes both manual removals and automatic evictions due to capacity or expiry.\n func (c *Expirable[K, V]) OnEvict(f OnEvictFunc[K, V]) {\n","filediff":{"file":"/Users/rselbach/devel/lru/expirable.go","before":"// Package lru provides a generic, thread-safe LRU cache implementation.\npackage lru\n\nimport (\n\t\"container/list\"\n\t\"errors\"\n\t\"sync\"\n\t\"time\"\n)\n\n// expirableEntry extends cacheEntry with an expiry time.\ntype expirableEntry[K comparable, V any] struct {\n\tkey    K\n\tval    V\n\texpiry time.Time\n}\n\n// Expirable represents a thread-safe, fixed-size LRU cache with expiry functionality.\ntype Expirable[K comparable, V any] struct {\n\tcapacity int\n\titems    map[K]*list.Element\n\tlruList  *list.List\n\tmu       sync.RWMutex\n\tttl      time.Duration\n\ttimeNow  func() time.Time  // for testing\n\tonEvict  OnEvictFunc[K, V] // callback for evictions\n}\n\n// NewExpirable creates a new LRU cache with the given capacity and TTL.\n// Items will be automatically removed from the cache when they expire.\n// The capacity must be greater than zero, and the TTL must be greater than zero.\nfunc NewExpirable[K comparable, V any](capacity int, ttl time.Duration) (*Expirable[K, V], error) {\n\tif capacity <= 0 {\n\t\treturn nil, errors.New(\"capacity must be greater than zero\")\n\t}\n\tif ttl <= 0 {\n\t\treturn nil, errors.New(\"TTL must be greater than zero\")\n\t}\n\n\treturn &Expirable[K, V]{\n\t\tcapacity: capacity,\n\t\titems:    make(map[K]*list.Element),\n\t\tlruList:  list.New(),\n\t\tttl:      ttl,\n\t\ttimeNow:  time.Now,\n\t}, nil\n}\n\n// MustNewExpirable creates a new LRU cache with the given capacity and TTL.\n// It panics if the capacity or TTL is less than or equal to zero.\nfunc MustNewExpirable[K comparable, V any](capacity int, ttl time.Duration) *Expirable[K, V] {\n\tcache, err := NewExpirable[K, V](capacity, ttl)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn cache\n}\n\n// Get retrieves a value from the cache by key.\n// It returns the value and a boolean indicating whether the key was found and not expired.\n// This method also updates the item's position in the LRU list.\n// Expired items are removed when accessed.\nfunc (c *Expirable[K, V]) Get(key K) (V, bool) {\n\tc.mu.Lock()\n\n\tvar zero V\n\n\telement, found := c.items[key]\n\tif !found {\n\t\tc.mu.Unlock()\n\t\treturn zero, false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\n\t// check if the entry has expired\n\tif c.timeNow().After(entry.expiry) {\n\t\tevictedKey := entry.key\n\t\tevictedVal := entry.val\n\t\tonEvict := c.onEvict\n\t\tdelete(c.items, entry.key)\n\t\tc.lruList.Remove(element)\n\t\tc.mu.Unlock()\n\n\t\tif onEvict != nil {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t\treturn zero, false\n\t}\n\n\t// move to front of list to mark as recently used\n\tc.lruList.MoveToFront(element)\n\tval := entry.val\n\tc.mu.Unlock()\n\n\treturn val, true\n}\n\n// GetWithTTL retrieves a value and its remaining TTL from the cache by key.\n// It returns the value, remaining TTL, and a boolean indicating whether the key was found and not expired.\n// Expired items are removed when accessed.\nfunc (c *Expirable[K, V]) GetWithTTL(key K) (V, time.Duration, bool) {\n\tc.mu.Lock()\n\n\tvar zero V\n\n\telement, found := c.items[key]\n\tif !found {\n\t\tc.mu.Unlock()\n\t\treturn zero, 0, false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\n\tnow := c.timeNow()\n\t// check if the entry has expired\n\tif now.After(entry.expiry) {\n\t\tevictedKey := entry.key\n\t\tevictedVal := entry.val\n\t\tonEvict := c.onEvict\n\t\tdelete(c.items, entry.key)\n\t\tc.lruList.Remove(element)\n\t\tc.mu.Unlock()\n\n\t\tif onEvict != nil {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t\treturn zero, 0, false\n\t}\n\n\t// move to front of list to mark as recently used\n\tc.lruList.MoveToFront(element)\n\n\t// calculate remaining TTL\n\tttl := entry.expiry.Sub(now)\n\tif ttl < 0 {\n\t\tttl = 0\n\t}\n\tval := entry.val\n\tc.mu.Unlock()\n\n\treturn val, ttl, true\n}\n\n// GetOrSet retrieves a value from the cache by key, or computes and sets it if not present or expired.\n// The compute function is only called if the key is not present in the cache or is expired.\n// Note: if multiple goroutines call GetOrSet concurrently for the same missing/expired key,\n// compute may be called multiple times but only one result will be cached.\nfunc (c *Expirable[K, V]) GetOrSet(key K, compute func() (V, error)) (V, error) {\n\t// first try to get the item without a write lock\n\tif val, found := c.Get(key); found {\n\t\treturn val, nil\n\t}\n\n\t// compute the value outside the lock to avoid deadlock if compute\n\t// calls back into the cache\n\tval, err := compute()\n\tif err != nil {\n\t\tvar zero V\n\t\treturn zero, err\n\t}\n\n\tc.mu.Lock()\n\t// check again in case it was added while we were computing\n\telement, found := c.items[key]\n\tvar expiredEntry *expirableEntry[K, V]\n\tif found {\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif !c.timeNow().After(entry.expiry) {\n\t\t\tc.lruList.MoveToFront(element)\n\t\t\tval := entry.val\n\t\t\tc.mu.Unlock()\n\t\t\treturn val, nil\n\t\t}\n\t\t// expired entry, remove it and save for callback\n\t\texpiredEntry = entry\n\t\tdelete(c.items, key)\n\t\tc.lruList.Remove(element)\n\t}\n\n\t// add to cache\n\tevictedKey, evictedVal, hasEvicted := c.setLocked(key, val)\n\tonEvict := c.onEvict\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tif expiredEntry != nil {\n\t\t\tonEvict(expiredEntry.key, expiredEntry.val)\n\t\t}\n\t\tif hasEvicted {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t}\n\treturn val, nil\n}\n\n// Set adds or updates an item in the cache.\n// If the key already exists, its value is updated.\n// If the cache is at capacity, the least recently used item is evicted.\n// Any expired items are automatically removed when adding a new item.\nfunc (c *Expirable[K, V]) Set(key K, value V) {\n\tc.mu.Lock()\n\texpired := c.removeExpiredLocked()\n\tevictedKey, evictedVal, hasEvicted := c.setLocked(key, value)\n\tonEvict := c.onEvict\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tfor _, entry := range expired {\n\t\t\tonEvict(entry.key, entry.val)\n\t\t}\n\t\tif hasEvicted {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t}\n}\n\n// setLocked is an internal method that adds or updates an item in the cache.\n// it assumes the mutex is already locked and expired items have been removed.\n// Returns the evicted key/value and whether an eviction occurred.\nfunc (c *Expirable[K, V]) setLocked(key K, value V) (evictedKey K, evictedVal V, evicted bool) {\n\t// if key exists, update value and expiry and move to front\n\tif element, found := c.items[key]; found {\n\t\tc.lruList.MoveToFront(element)\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tentry.val = value\n\t\tentry.expiry = c.timeNow().Add(c.ttl)\n\t\treturn\n\t}\n\n\t// if we're at capacity, remove the least recently used item\n\tif c.lruList.Len() >= c.capacity {\n\t\toldest := c.lruList.Back()\n\t\tif oldest != nil {\n\t\t\tentry := oldest.Value.(*expirableEntry[K, V])\n\t\t\tevictedKey = entry.key\n\t\t\tevictedVal = entry.val\n\t\t\tevicted = true\n\t\t\tdelete(c.items, entry.key)\n\t\t\tc.lruList.Remove(oldest)\n\t\t}\n\t}\n\n\t// add new item\n\tentry := &expirableEntry[K, V]{\n\t\tkey:    key,\n\t\tval:    value,\n\t\texpiry: c.timeNow().Add(c.ttl),\n\t}\n\telement := c.lruList.PushFront(entry)\n\tc.items[key] = element\n\treturn\n}\n\n// Remove deletes an item from the cache by key.\n// It returns whether the key was found and removed.\nfunc (c *Expirable[K, V]) Remove(key K) bool {\n\tc.mu.Lock()\n\texpired := c.removeExpiredLocked()\n\n\telement, found := c.items[key]\n\tif !found {\n\t\tonEvict := c.onEvict\n\t\tc.mu.Unlock()\n\t\tif onEvict != nil {\n\t\t\tfor _, entry := range expired {\n\t\t\t\tonEvict(entry.key, entry.val)\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\tevictedKey := entry.key\n\tevictedVal := entry.val\n\tonEvict := c.onEvict\n\n\tdelete(c.items, key)\n\tc.lruList.Remove(element)\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tfor _, e := range expired {\n\t\t\tonEvict(e.key, e.val)\n\t\t}\n\t\tonEvict(evictedKey, evictedVal)\n\t}\n\treturn true\n}\n\n// Len returns the current number of non-expired items in the cache.\nfunc (c *Expirable[K, V]) Len() int {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\t// we'll need to count non-expired entries\n\tcount := 0\n\tnow := c.timeNow()\n\n\tfor _, element := range c.items {\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif !now.After(entry.expiry) {\n\t\t\tcount++\n\t\t}\n\t}\n\n\treturn count\n}\n\n// Clear removes all items from the cache.\nfunc (c *Expirable[K, V]) Clear() {\n\tc.mu.Lock()\n\tonEvict := c.onEvict\n\n\tvar evicted []expirableEntry[K, V]\n\tif onEvict != nil {\n\t\tnow := c.timeNow()\n\t\tevicted = make([]expirableEntry[K, V], 0, c.lruList.Len())\n\t\tfor element := c.lruList.Front(); element != nil; element = element.Next() {\n\t\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\t\tif !now.After(entry.expiry) {\n\t\t\t\tevicted = append(evicted, *entry)\n\t\t\t}\n\t\t}\n\t}\n\n\tc.items = make(map[K]*list.Element)\n\tc.lruList = list.New()\n\tc.mu.Unlock()\n\n\tfor _, entry := range evicted {\n\t\tonEvict(entry.key, entry.val)\n\t}\n}\n\n// Contains checks if a key exists in the cache and is not expired.\nfunc (c *Expirable[K, V]) Contains(key K) bool {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\telement, found := c.items[key]\n\tif !found {\n\t\treturn false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\treturn !c.timeNow().After(entry.expiry)\n}\n\n// Keys returns a slice of all keys in the cache that haven't expired.\n// The order is from most recently used to least recently used.\nfunc (c *Expirable[K, V]) Keys() []K {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tnow := c.timeNow()\n\tkeys := make([]K, 0, len(c.items))\n\n\tfor element := c.lruList.Front(); element != nil; element = element.Next() {\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif !now.After(entry.expiry) {\n\t\t\tkeys = append(keys, entry.key)\n\t\t}\n\t}\n\n\treturn keys\n}\n\n// Capacity returns the maximum capacity of the cache.\nfunc (c *Expirable[K, V]) Capacity() int {\n\treturn c.capacity\n}\n\n// TTL returns the time-to-live duration for cache entries.\nfunc (c *Expirable[K, V]) TTL() time.Duration {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\treturn c.ttl\n}\n\n// SetTTL updates the TTL for future cache entries.\n// It does not affect existing entries.\nfunc (c *Expirable[K, V]) SetTTL(ttl time.Duration) error {\n\tif ttl <= 0 {\n\t\treturn errors.New(\"TTL must be greater than zero\")\n\t}\n\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tc.ttl = ttl\n\treturn nil\n}\n\n// SetTimeNowFunc allows replacing the function used to get the current time.\n// This is primarily used for testing.\nfunc (c *Expirable[K, V]) SetTimeNowFunc(f func() time.Time) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tc.timeNow = f\n}\n\n// OnEvict sets a callback function that will be called when an entry is evicted from the cache.\n// The callback will receive the key and value of the evicted entry.\n// This includes both manual removals and automatic evictions due to capacity or expiry.\nfunc (c *Expirable[K, V]) OnEvict(f OnEvictFunc[K, V]) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tc.onEvict = f\n}\n\n// removeExpiredLocked removes all expired items from the cache.\n// it assumes the mutex is already locked.\n// Returns a slice of expired entries for callback invocation outside the lock.\nfunc (c *Expirable[K, V]) removeExpiredLocked() []expirableEntry[K, V] {\n\tnow := c.timeNow()\n\tvar expired []expirableEntry[K, V]\n\n\tfor element := c.lruList.Front(); element != nil; {\n\t\tnextElement := element.Next()\n\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif now.After(entry.expiry) {\n\t\t\texpired = append(expired, *entry)\n\t\t\tdelete(c.items, entry.key)\n\t\t\tc.lruList.Remove(element)\n\t\t}\n\n\t\telement = nextElement\n\t}\n\treturn expired\n}\n\n// RemoveExpired explicitly removes all expired items from the cache.\n// Returns the number of items removed.\n// This method will call the eviction callback for each expired item if one is set.\nfunc (c *Expirable[K, V]) RemoveExpired() int {\n\tc.mu.Lock()\n\n\tnow := c.timeNow()\n\tremoved := 0\n\n\texpiredItems := make([]K, 0)\n\texpiredValues := make([]V, 0)\n\n\tfor element := c.lruList.Front(); element != nil; {\n\t\tnextElement := element.Next()\n\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif now.After(entry.expiry) {\n\t\t\texpiredItems = append(expiredItems, entry.key)\n\t\t\texpiredValues = append(expiredValues, entry.val)\n\t\t\tdelete(c.items, entry.key)\n\t\t\tc.lruList.Remove(element)\n\t\t\tremoved++\n\t\t}\n\n\t\telement = nextElement\n\t}\n\n\tonEvict := c.onEvict\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tfor i := range expiredItems {\n\t\t\tonEvict(expiredItems[i], expiredValues[i])\n\t\t}\n\t}\n\n\treturn removed\n}\n","after":"// Package lru provides a generic, thread-safe LRU cache implementation.\npackage lru\n\nimport (\n\t\"container/list\"\n\t\"errors\"\n\t\"sync\"\n\t\"time\"\n)\n\n// expirableEntry extends cacheEntry with an expiry time.\ntype expirableEntry[K comparable, V any] struct {\n\tkey    K\n\tval    V\n\texpiry time.Time\n}\n\n// Expirable represents a thread-safe, fixed-size LRU cache with expiry functionality.\ntype Expirable[K comparable, V any] struct {\n\tcapacity int\n\titems    map[K]*list.Element\n\tlruList  *list.List\n\tmu       sync.RWMutex\n\tttl      time.Duration\n\ttimeNow  func() time.Time  // for testing\n\tonEvict  OnEvictFunc[K, V] // callback for evictions\n}\n\n// NewExpirable creates a new LRU cache with the given capacity and TTL.\n// Items will be automatically removed from the cache when they expire.\n// The capacity must be greater than zero, and the TTL must be greater than zero.\nfunc NewExpirable[K comparable, V any](capacity int, ttl time.Duration) (*Expirable[K, V], error) {\n\tif capacity <= 0 {\n\t\treturn nil, errors.New(\"capacity must be greater than zero\")\n\t}\n\tif ttl <= 0 {\n\t\treturn nil, errors.New(\"TTL must be greater than zero\")\n\t}\n\n\treturn &Expirable[K, V]{\n\t\tcapacity: capacity,\n\t\titems:    make(map[K]*list.Element),\n\t\tlruList:  list.New(),\n\t\tttl:      ttl,\n\t\ttimeNow:  time.Now,\n\t}, nil\n}\n\n// MustNewExpirable creates a new LRU cache with the given capacity and TTL.\n// It panics if the capacity or TTL is less than or equal to zero.\nfunc MustNewExpirable[K comparable, V any](capacity int, ttl time.Duration) *Expirable[K, V] {\n\tcache, err := NewExpirable[K, V](capacity, ttl)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn cache\n}\n\n// Get retrieves a value from the cache by key.\n// It returns the value and a boolean indicating whether the key was found and not expired.\n// This method also updates the item's position in the LRU list.\n// Expired items are removed when accessed.\nfunc (c *Expirable[K, V]) Get(key K) (V, bool) {\n\tc.mu.Lock()\n\n\tvar zero V\n\n\telement, found := c.items[key]\n\tif !found {\n\t\tc.mu.Unlock()\n\t\treturn zero, false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\n\t// check if the entry has expired\n\tif c.timeNow().After(entry.expiry) {\n\t\tevictedKey := entry.key\n\t\tevictedVal := entry.val\n\t\tonEvict := c.onEvict\n\t\tdelete(c.items, entry.key)\n\t\tc.lruList.Remove(element)\n\t\tc.mu.Unlock()\n\n\t\tif onEvict != nil {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t\treturn zero, false\n\t}\n\n\t// move to front of list to mark as recently used\n\tc.lruList.MoveToFront(element)\n\tval := entry.val\n\tc.mu.Unlock()\n\n\treturn val, true\n}\n\n// GetWithTTL retrieves a value and its remaining TTL from the cache by key.\n// It returns the value, remaining TTL, and a boolean indicating whether the key was found and not expired.\n// Expired items are removed when accessed.\nfunc (c *Expirable[K, V]) GetWithTTL(key K) (V, time.Duration, bool) {\n\tc.mu.Lock()\n\n\tvar zero V\n\n\telement, found := c.items[key]\n\tif !found {\n\t\tc.mu.Unlock()\n\t\treturn zero, 0, false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\n\tnow := c.timeNow()\n\t// check if the entry has expired\n\tif now.After(entry.expiry) {\n\t\tevictedKey := entry.key\n\t\tevictedVal := entry.val\n\t\tonEvict := c.onEvict\n\t\tdelete(c.items, entry.key)\n\t\tc.lruList.Remove(element)\n\t\tc.mu.Unlock()\n\n\t\tif onEvict != nil {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t\treturn zero, 0, false\n\t}\n\n\t// move to front of list to mark as recently used\n\tc.lruList.MoveToFront(element)\n\n\t// calculate remaining TTL\n\tttl := entry.expiry.Sub(now)\n\tif ttl < 0 {\n\t\tttl = 0\n\t}\n\tval := entry.val\n\tc.mu.Unlock()\n\n\treturn val, ttl, true\n}\n\n// GetOrSet retrieves a value from the cache by key, or computes and sets it if not present or expired.\n// The compute function is only called if the key is not present in the cache or is expired.\n// Note: if multiple goroutines call GetOrSet concurrently for the same missing/expired key,\n// compute may be called multiple times but only one result will be cached.\nfunc (c *Expirable[K, V]) GetOrSet(key K, compute func() (V, error)) (V, error) {\n\t// first try to get the item without a write lock\n\tif val, found := c.Get(key); found {\n\t\treturn val, nil\n\t}\n\n\t// compute the value outside the lock to avoid deadlock if compute\n\t// calls back into the cache\n\tval, err := compute()\n\tif err != nil {\n\t\tvar zero V\n\t\treturn zero, err\n\t}\n\n\tc.mu.Lock()\n\t// check again in case it was added while we were computing\n\telement, found := c.items[key]\n\tvar expiredEntry *expirableEntry[K, V]\n\tif found {\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif !c.timeNow().After(entry.expiry) {\n\t\t\tc.lruList.MoveToFront(element)\n\t\t\tval := entry.val\n\t\t\tc.mu.Unlock()\n\t\t\treturn val, nil\n\t\t}\n\t\t// expired entry, remove it and save for callback\n\t\texpiredEntry = entry\n\t\tdelete(c.items, key)\n\t\tc.lruList.Remove(element)\n\t}\n\n\t// add to cache\n\tevictedKey, evictedVal, hasEvicted := c.setLocked(key, val)\n\tonEvict := c.onEvict\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tif expiredEntry != nil {\n\t\t\tonEvict(expiredEntry.key, expiredEntry.val)\n\t\t}\n\t\tif hasEvicted {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t}\n\treturn val, nil\n}\n\n// Set adds or updates an item in the cache.\n// If the key already exists, its value is updated.\n// If the cache is at capacity, the least recently used item is evicted.\n// Any expired items are automatically removed when adding a new item.\nfunc (c *Expirable[K, V]) Set(key K, value V) {\n\tc.mu.Lock()\n\texpired := c.removeExpiredLocked()\n\tevictedKey, evictedVal, hasEvicted := c.setLocked(key, value)\n\tonEvict := c.onEvict\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tfor _, entry := range expired {\n\t\t\tonEvict(entry.key, entry.val)\n\t\t}\n\t\tif hasEvicted {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t}\n}\n\n// setLocked is an internal method that adds or updates an item in the cache.\n// it assumes the mutex is already locked and expired items have been removed.\n// Returns the evicted key/value and whether an eviction occurred.\nfunc (c *Expirable[K, V]) setLocked(key K, value V) (evictedKey K, evictedVal V, evicted bool) {\n\t// if key exists, update value and expiry and move to front\n\tif element, found := c.items[key]; found {\n\t\tc.lruList.MoveToFront(element)\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tentry.val = value\n\t\tentry.expiry = c.timeNow().Add(c.ttl)\n\t\treturn\n\t}\n\n\t// if we're at capacity, remove the least recently used item\n\tif c.lruList.Len() >= c.capacity {\n\t\toldest := c.lruList.Back()\n\t\tif oldest != nil {\n\t\t\tentry := oldest.Value.(*expirableEntry[K, V])\n\t\t\tevictedKey = entry.key\n\t\t\tevictedVal = entry.val\n\t\t\tevicted = true\n\t\t\tdelete(c.items, entry.key)\n\t\t\tc.lruList.Remove(oldest)\n\t\t}\n\t}\n\n\t// add new item\n\tentry := &expirableEntry[K, V]{\n\t\tkey:    key,\n\t\tval:    value,\n\t\texpiry: c.timeNow().Add(c.ttl),\n\t}\n\telement := c.lruList.PushFront(entry)\n\tc.items[key] = element\n\treturn\n}\n\n// Remove deletes an item from the cache by key.\n// It returns whether the key was found and removed.\nfunc (c *Expirable[K, V]) Remove(key K) bool {\n\tc.mu.Lock()\n\texpired := c.removeExpiredLocked()\n\n\telement, found := c.items[key]\n\tif !found {\n\t\tonEvict := c.onEvict\n\t\tc.mu.Unlock()\n\t\tif onEvict != nil {\n\t\t\tfor _, entry := range expired {\n\t\t\t\tonEvict(entry.key, entry.val)\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\tevictedKey := entry.key\n\tevictedVal := entry.val\n\tonEvict := c.onEvict\n\n\tdelete(c.items, key)\n\tc.lruList.Remove(element)\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tfor _, e := range expired {\n\t\t\tonEvict(e.key, e.val)\n\t\t}\n\t\tonEvict(evictedKey, evictedVal)\n\t}\n\treturn true\n}\n\n// Len returns the current number of non-expired items in the cache.\nfunc (c *Expirable[K, V]) Len() int {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\t// we'll need to count non-expired entries\n\tcount := 0\n\tnow := c.timeNow()\n\n\tfor _, element := range c.items {\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif !now.After(entry.expiry) {\n\t\t\tcount++\n\t\t}\n\t}\n\n\treturn count\n}\n\n// Clear removes all items from the cache.\nfunc (c *Expirable[K, V]) Clear() {\n\tc.mu.Lock()\n\tonEvict := c.onEvict\n\n\tvar evicted []expirableEntry[K, V]\n\tif onEvict != nil {\n\t\tnow := c.timeNow()\n\t\tevicted = make([]expirableEntry[K, V], 0, c.lruList.Len())\n\t\tfor element := c.lruList.Front(); element != nil; element = element.Next() {\n\t\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\t\tif !now.After(entry.expiry) {\n\t\t\t\tevicted = append(evicted, *entry)\n\t\t\t}\n\t\t}\n\t}\n\n\tc.items = make(map[K]*list.Element)\n\tc.lruList = list.New()\n\tc.mu.Unlock()\n\n\tfor _, entry := range evicted {\n\t\tonEvict(entry.key, entry.val)\n\t}\n}\n\n// Contains checks if a key exists in the cache and is not expired.\nfunc (c *Expirable[K, V]) Contains(key K) bool {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\telement, found := c.items[key]\n\tif !found {\n\t\treturn false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\treturn !c.timeNow().After(entry.expiry)\n}\n\n// Keys returns a slice of all keys in the cache that haven't expired.\n// The order is from most recently used to least recently used.\nfunc (c *Expirable[K, V]) Keys() []K {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tnow := c.timeNow()\n\tkeys := make([]K, 0, len(c.items))\n\n\tfor element := c.lruList.Front(); element != nil; element = element.Next() {\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif !now.After(entry.expiry) {\n\t\t\tkeys = append(keys, entry.key)\n\t\t}\n\t}\n\n\treturn keys\n}\n\n// Capacity returns the maximum capacity of the cache.\nfunc (c *Expirable[K, V]) Capacity() int {\n\treturn c.capacity\n}\n\n// TTL returns the time-to-live duration for cache entries.\nfunc (c *Expirable[K, V]) TTL() time.Duration {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\treturn c.ttl\n}\n\n// SetTTL updates the TTL for future cache entries.\n// It does not affect existing entries.\nfunc (c *Expirable[K, V]) SetTTL(ttl time.Duration) error {\n\tif ttl <= 0 {\n\t\treturn errors.New(\"TTL must be greater than zero\")\n\t}\n\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tc.ttl = ttl\n\treturn nil\n}\n\n// OnEvict sets a callback function that will be called when an entry is evicted from the cache.\n// The callback will receive the key and value of the evicted entry.\n// This includes both manual removals and automatic evictions due to capacity or expiry.\nfunc (c *Expirable[K, V]) OnEvict(f OnEvictFunc[K, V]) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tc.onEvict = f\n}\n\n// removeExpiredLocked removes all expired items from the cache.\n// it assumes the mutex is already locked.\n// Returns a slice of expired entries for callback invocation outside the lock.\nfunc (c *Expirable[K, V]) removeExpiredLocked() []expirableEntry[K, V] {\n\tnow := c.timeNow()\n\tvar expired []expirableEntry[K, V]\n\n\tfor element := c.lruList.Front(); element != nil; {\n\t\tnextElement := element.Next()\n\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif now.After(entry.expiry) {\n\t\t\texpired = append(expired, *entry)\n\t\t\tdelete(c.items, entry.key)\n\t\t\tc.lruList.Remove(element)\n\t\t}\n\n\t\telement = nextElement\n\t}\n\treturn expired\n}\n\n// RemoveExpired explicitly removes all expired items from the cache.\n// Returns the number of items removed.\n// This method will call the eviction callback for each expired item if one is set.\nfunc (c *Expirable[K, V]) RemoveExpired() int {\n\tc.mu.Lock()\n\n\tnow := c.timeNow()\n\tremoved := 0\n\n\texpiredItems := make([]K, 0)\n\texpiredValues := make([]V, 0)\n\n\tfor element := c.lruList.Front(); element != nil; {\n\t\tnextElement := element.Next()\n\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif now.After(entry.expiry) {\n\t\t\texpiredItems = append(expiredItems, entry.key)\n\t\t\texpiredValues = append(expiredValues, entry.val)\n\t\t\tdelete(c.items, entry.key)\n\t\t\tc.lruList.Remove(element)\n\t\t\tremoved++\n\t\t}\n\n\t\telement = nextElement\n\t}\n\n\tonEvict := c.onEvict\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tfor i := range expiredItems {\n\t\t\tonEvict(expiredItems[i], expiredValues[i])\n\t\t}\n\t}\n\n\treturn removed\n}\n","additions":0,"deletions":9}}}
{"type":"tool_use","timestamp":"2025-12-29T19:41:35.500Z","tool_name":"edit","tool_input":{"filePath":"/Users/rselbach/devel/lru/callbacks_test.go","oldString":"\t// Override the timeNow function to use our mock\n\tcache.SetTimeNowFunc(mockClock.Now)","newString":"\t// Override the timeNow function to use our mock\n\tcache.timeNow = mockClock.Now","replaceAll":true}}
{"type":"tool_result","timestamp":"2025-12-29T19:41:35.663Z","tool_name":"edit","tool_input":{"filePath":"/Users/rselbach/devel/lru/callbacks_test.go","oldString":"\t// Override the timeNow function to use our mock\n\tcache.SetTimeNowFunc(mockClock.Now)","newString":"\t// Override the timeNow function to use our mock\n\tcache.timeNow = mockClock.Now","replaceAll":true},"tool_output":{"diagnostics":{"/Users/rselbach/devel/lru/lru.go":[],"/Users/rselbach/devel/lru/expirable.go":[],"/Users/rselbach/devel/lru/lru_test.go":[],"/Users/rselbach/devel/lru/expirable_test.go":[],"/Users/rselbach/devel/lru/callbacks_test.go":[],"/Users/rselbach/devel/lru/expirable_example_test.go":[{"range":{"start":{"line":49,"character":7},"end":{"line":49,"character":21}},"severity":1,"code":"MissingFieldOrMethod","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#MissingFieldOrMethod"},"source":"compiler","message":"cache.SetTimeNowFunc undefined (type *lru.Expirable[string, string] has no field or method SetTimeNowFunc)"},{"range":{"start":{"line":116,"character":7},"end":{"line":116,"character":21}},"severity":1,"code":"MissingFieldOrMethod","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#MissingFieldOrMethod"},"source":"compiler","message":"cache.SetTimeNowFunc undefined (type *lru.Expirable[string, string] has no field or method SetTimeNowFunc)"},{"range":{"start":{"line":168,"character":8},"end":{"line":168,"character":22}},"severity":1,"code":"MissingFieldOrMethod","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#MissingFieldOrMethod"},"source":"compiler","message":"cache.SetTimeNowFunc undefined (type *lru.Expirable[string, int] has no field or method SetTimeNowFunc)"}]},"diff":"Index: /Users/rselbach/devel/lru/callbacks_test.go\n===================================================================\n--- /Users/rselbach/devel/lru/callbacks_test.go\n+++ /Users/rselbach/devel/lru/callbacks_test.go\n@@ -89,9 +89,9 @@\n cache, err := NewExpirable[string, int](3, time.Minute)\n r.NoError(err)\n \n // Override the timeNow function to use our mock\n-cache.SetTimeNowFunc(mockClock.Now)\n+cache.timeNow = mockClock.Now\n \n evicted := make(map[string]int)\n cache.OnEvict(func(key string, value int) {\n \tevicted[key] = value\n@@ -144,9 +144,9 @@\n cache, err := NewExpirable[string, int](3, time.Minute)\n r.NoError(err)\n \n // Override the timeNow function to use our mock\n-cache.SetTimeNowFunc(mockClock.Now)\n+cache.timeNow = mockClock.Now\n \n evicted := make(map[string]int)\n cache.OnEvict(func(key string, value int) {\n \tevicted[key] = value\n","filediff":{"file":"/Users/rselbach/devel/lru/callbacks_test.go","before":"package lru\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestCache_OnEvict(t *testing.T) {\n\tr := require.New(t)\n\tcache := MustNew[string, int](3)\n\n\tevicted := make(map[string]int)\n\tcache.OnEvict(func(key string, value int) {\n\t\tevicted[key] = value\n\t})\n\n\t// Add items to the cache\n\tcache.Set(\"a\", 1)\n\tcache.Set(\"b\", 2)\n\tcache.Set(\"c\", 3)\n\n\t// No evictions yet\n\tr.Empty(evicted)\n\n\t// This should evict \"a\" since it's the least recently used\n\tcache.Set(\"d\", 4)\n\tr.Equal(map[string]int{\"a\": 1}, evicted)\n\n\t// Test explicit removal\n\tcache.Remove(\"b\")\n\tr.Equal(map[string]int{\"a\": 1, \"b\": 2}, evicted)\n\n\t// Update \"c\" - should not trigger eviction\n\tcache.Set(\"c\", 30)\n\tr.Equal(map[string]int{\"a\": 1, \"b\": 2}, evicted)\n\n\t// Clear the cache - should evict all remaining items\n\tcache.Clear()\n\tr.Equal(map[string]int{\"a\": 1, \"b\": 2, \"c\": 30, \"d\": 4}, evicted)\n}\n\nfunc TestCache_OnEvictReplacement(t *testing.T) {\n\tr := require.New(t)\n\tcache := MustNew[string, int](3)\n\n\tevicted1 := make(map[string]int)\n\tcache.OnEvict(func(key string, value int) {\n\t\tevicted1[key] = value\n\t})\n\n\t// Add items and cause an eviction\n\tcache.Set(\"a\", 1)\n\tcache.Set(\"b\", 2)\n\tcache.Set(\"c\", 3)\n\tcache.Set(\"d\", 4) // should evict \"a\"\n\n\tr.Equal(map[string]int{\"a\": 1}, evicted1)\n\n\t// Replace the callback\n\tevicted2 := make(map[string]int)\n\tcache.OnEvict(func(key string, value int) {\n\t\tevicted2[key] = value\n\t})\n\n\t// Cause another eviction\n\tcache.Set(\"e\", 5) // should evict \"b\"\n\n\t// The new callback should be called, not the old one\n\tr.Equal(map[string]int{\"a\": 1}, evicted1)\n\tr.Equal(map[string]int{\"b\": 2}, evicted2)\n\n\t// Set callback to nil\n\tcache.OnEvict(nil)\n\n\t// Cause another eviction\n\tcache.Set(\"f\", 6) // should evict \"c\"\n\n\t// No callback should be called\n\tr.Equal(map[string]int{\"a\": 1}, evicted1)\n\tr.Equal(map[string]int{\"b\": 2}, evicted2)\n}\n\nfunc TestExpirable_OnEvict(t *testing.T) {\n\tr := require.New(t)\n\tmockClock := newMockTime()\n\n\tcache, err := NewExpirable[string, int](3, time.Minute)\n\tr.NoError(err)\n\n\t// Override the timeNow function to use our mock\n\tcache.SetTimeNowFunc(mockClock.Now)\n\n\tevicted := make(map[string]int)\n\tcache.OnEvict(func(key string, value int) {\n\t\tevicted[key] = value\n\t})\n\n\t// Add items to the cache\n\tcache.Set(\"a\", 1)\n\tcache.Set(\"b\", 2)\n\tcache.Set(\"c\", 3)\n\n\t// No evictions yet\n\tr.Empty(evicted)\n\n\t// This should evict \"a\" since it's the least recently used\n\tcache.Set(\"d\", 4)\n\tr.Equal(map[string]int{\"a\": 1}, evicted)\n\n\t// Test explicit removal\n\tcache.Remove(\"b\")\n\tr.Equal(map[string]int{\"a\": 1, \"b\": 2}, evicted)\n\n\t// Advance time past expiration\n\tmockClock.Add(time.Minute + time.Second)\n\n\t// The expired items won't be evicted until accessed or a write operation\n\tr.Equal(map[string]int{\"a\": 1, \"b\": 2}, evicted)\n\n\t// This should call the callback for expired items removed during Set\n\tcache.Set(\"e\", 5)\n\tr.Equal(map[string]int{\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4}, evicted)\n\n\t// Add new items to test RemoveExpired with callbacks\n\tevicted = make(map[string]int) // Reset the eviction map\n\tcache.Set(\"f\", 6)\n\tcache.Set(\"g\", 7)\n\n\t// Advance time past expiration again\n\tmockClock.Add(time.Minute + time.Second)\n\n\t// Explicit removal should call callbacks\n\tremoved := cache.RemoveExpired()\n\tr.Equal(3, removed) // should remove e, f, g\n\tr.Equal(map[string]int{\"e\": 5, \"f\": 6, \"g\": 7}, evicted)\n}\n\nfunc TestExpirable_Clear(t *testing.T) {\n\tr := require.New(t)\n\tmockClock := newMockTime()\n\n\tcache, err := NewExpirable[string, int](3, time.Minute)\n\tr.NoError(err)\n\n\t// Override the timeNow function to use our mock\n\tcache.SetTimeNowFunc(mockClock.Now)\n\n\tevicted := make(map[string]int)\n\tcache.OnEvict(func(key string, value int) {\n\t\tevicted[key] = value\n\t})\n\n\t// Add items to the cache\n\tcache.Set(\"a\", 1)\n\tcache.Set(\"b\", 2)\n\tcache.Set(\"c\", 3)\n\n\t// No evictions yet\n\tr.Empty(evicted)\n\n\t// Advance time past expiration for \"a\" and \"b\" but not \"c\"\n\tmockClock.Add(30 * time.Second)\n\tcache.Set(\"c\", 30)              // update c's TTL\n\tmockClock.Add(31 * time.Second) // now a and b are expired but c is not\n\n\t// Clear should only call callback for non-expired items\n\tcache.Clear()\n\tr.Equal(map[string]int{\"c\": 30}, evicted)\n}\n","after":"package lru\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestCache_OnEvict(t *testing.T) {\n\tr := require.New(t)\n\tcache := MustNew[string, int](3)\n\n\tevicted := make(map[string]int)\n\tcache.OnEvict(func(key string, value int) {\n\t\tevicted[key] = value\n\t})\n\n\t// Add items to the cache\n\tcache.Set(\"a\", 1)\n\tcache.Set(\"b\", 2)\n\tcache.Set(\"c\", 3)\n\n\t// No evictions yet\n\tr.Empty(evicted)\n\n\t// This should evict \"a\" since it's the least recently used\n\tcache.Set(\"d\", 4)\n\tr.Equal(map[string]int{\"a\": 1}, evicted)\n\n\t// Test explicit removal\n\tcache.Remove(\"b\")\n\tr.Equal(map[string]int{\"a\": 1, \"b\": 2}, evicted)\n\n\t// Update \"c\" - should not trigger eviction\n\tcache.Set(\"c\", 30)\n\tr.Equal(map[string]int{\"a\": 1, \"b\": 2}, evicted)\n\n\t// Clear the cache - should evict all remaining items\n\tcache.Clear()\n\tr.Equal(map[string]int{\"a\": 1, \"b\": 2, \"c\": 30, \"d\": 4}, evicted)\n}\n\nfunc TestCache_OnEvictReplacement(t *testing.T) {\n\tr := require.New(t)\n\tcache := MustNew[string, int](3)\n\n\tevicted1 := make(map[string]int)\n\tcache.OnEvict(func(key string, value int) {\n\t\tevicted1[key] = value\n\t})\n\n\t// Add items and cause an eviction\n\tcache.Set(\"a\", 1)\n\tcache.Set(\"b\", 2)\n\tcache.Set(\"c\", 3)\n\tcache.Set(\"d\", 4) // should evict \"a\"\n\n\tr.Equal(map[string]int{\"a\": 1}, evicted1)\n\n\t// Replace the callback\n\tevicted2 := make(map[string]int)\n\tcache.OnEvict(func(key string, value int) {\n\t\tevicted2[key] = value\n\t})\n\n\t// Cause another eviction\n\tcache.Set(\"e\", 5) // should evict \"b\"\n\n\t// The new callback should be called, not the old one\n\tr.Equal(map[string]int{\"a\": 1}, evicted1)\n\tr.Equal(map[string]int{\"b\": 2}, evicted2)\n\n\t// Set callback to nil\n\tcache.OnEvict(nil)\n\n\t// Cause another eviction\n\tcache.Set(\"f\", 6) // should evict \"c\"\n\n\t// No callback should be called\n\tr.Equal(map[string]int{\"a\": 1}, evicted1)\n\tr.Equal(map[string]int{\"b\": 2}, evicted2)\n}\n\nfunc TestExpirable_OnEvict(t *testing.T) {\n\tr := require.New(t)\n\tmockClock := newMockTime()\n\n\tcache, err := NewExpirable[string, int](3, time.Minute)\n\tr.NoError(err)\n\n\t// Override the timeNow function to use our mock\n\tcache.timeNow = mockClock.Now\n\n\tevicted := make(map[string]int)\n\tcache.OnEvict(func(key string, value int) {\n\t\tevicted[key] = value\n\t})\n\n\t// Add items to the cache\n\tcache.Set(\"a\", 1)\n\tcache.Set(\"b\", 2)\n\tcache.Set(\"c\", 3)\n\n\t// No evictions yet\n\tr.Empty(evicted)\n\n\t// This should evict \"a\" since it's the least recently used\n\tcache.Set(\"d\", 4)\n\tr.Equal(map[string]int{\"a\": 1}, evicted)\n\n\t// Test explicit removal\n\tcache.Remove(\"b\")\n\tr.Equal(map[string]int{\"a\": 1, \"b\": 2}, evicted)\n\n\t// Advance time past expiration\n\tmockClock.Add(time.Minute + time.Second)\n\n\t// The expired items won't be evicted until accessed or a write operation\n\tr.Equal(map[string]int{\"a\": 1, \"b\": 2}, evicted)\n\n\t// This should call the callback for expired items removed during Set\n\tcache.Set(\"e\", 5)\n\tr.Equal(map[string]int{\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4}, evicted)\n\n\t// Add new items to test RemoveExpired with callbacks\n\tevicted = make(map[string]int) // Reset the eviction map\n\tcache.Set(\"f\", 6)\n\tcache.Set(\"g\", 7)\n\n\t// Advance time past expiration again\n\tmockClock.Add(time.Minute + time.Second)\n\n\t// Explicit removal should call callbacks\n\tremoved := cache.RemoveExpired()\n\tr.Equal(3, removed) // should remove e, f, g\n\tr.Equal(map[string]int{\"e\": 5, \"f\": 6, \"g\": 7}, evicted)\n}\n\nfunc TestExpirable_Clear(t *testing.T) {\n\tr := require.New(t)\n\tmockClock := newMockTime()\n\n\tcache, err := NewExpirable[string, int](3, time.Minute)\n\tr.NoError(err)\n\n\t// Override the timeNow function to use our mock\n\tcache.timeNow = mockClock.Now\n\n\tevicted := make(map[string]int)\n\tcache.OnEvict(func(key string, value int) {\n\t\tevicted[key] = value\n\t})\n\n\t// Add items to the cache\n\tcache.Set(\"a\", 1)\n\tcache.Set(\"b\", 2)\n\tcache.Set(\"c\", 3)\n\n\t// No evictions yet\n\tr.Empty(evicted)\n\n\t// Advance time past expiration for \"a\" and \"b\" but not \"c\"\n\tmockClock.Add(30 * time.Second)\n\tcache.Set(\"c\", 30)              // update c's TTL\n\tmockClock.Add(31 * time.Second) // now a and b are expired but c is not\n\n\t// Clear should only call callback for non-expired items\n\tcache.Clear()\n\tr.Equal(map[string]int{\"c\": 30}, evicted)\n}\n","additions":2,"deletions":2}}}
{"type":"tool_use","timestamp":"2025-12-29T19:41:44.431Z","tool_name":"bash","tool_input":{"command":"cd /Users/rselbach/devel/lru && go test -race ./...","description":"Run tests to verify changes"}}
{"type":"tool_result","timestamp":"2025-12-29T19:41:44.678Z","tool_name":"bash","tool_input":{"command":"cd /Users/rselbach/devel/lru && go test -race ./...","description":"Run tests to verify changes","env":{"CI":"true","DEBIAN_FRONTEND":"noninteractive","GIT_TERMINAL_PROMPT":"0","GCM_INTERACTIVE":"never","HOMEBREW_NO_AUTO_UPDATE":"1","GIT_EDITOR":"true","EDITOR":"true","VISUAL":"true","GIT_SEQUENCE_EDITOR":"true","GIT_PAGER":"cat","PAGER":"cat","npm_config_yes":"true","PIP_NO_INPUT":"1","YARN_ENABLE_IMMUTABLE_INSTALLS":"false"}},"tool_output":{"output":"# github.com/rselbach/lru_test [github.com/rselbach/lru.test]\n./expirable_example_test.go:50:8: cache.SetTimeNowFunc undefined (type *lru.Expirable[string, string] has no field or method SetTimeNowFunc)\n./expirable_example_test.go:117:8: cache.SetTimeNowFunc undefined (type *lru.Expirable[string, string] has no field or method SetTimeNowFunc)\n./expirable_example_test.go:169:9: cache.SetTimeNowFunc undefined (type *lru.Expirable[string, int] has no field or method SetTimeNowFunc)\nFAIL\tgithub.com/rselbach/lru [build failed]\nFAIL\n","exit":1,"description":"Run tests to verify changes"}}
{"type":"tool_use","timestamp":"2025-12-29T19:41:54.021Z","tool_name":"read","tool_input":{"filePath":"/Users/rselbach/devel/lru/expirable_example_test.go"}}
{"type":"tool_result","timestamp":"2025-12-29T19:41:54.022Z","tool_name":"read","tool_input":{"filePath":"/Users/rselbach/devel/lru/expirable_example_test.go"},"tool_output":{"preview":"package lru_test\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/rselbach/lru\"\n)\n\n// This example demonstrates basic usage of the Expirable cache with time-to-live functionality.\nfunc Example_expirableBasic() {\n\t// Create a new Expirable cache with a capacity of 3 items and a TTL of 1 hour\n\tcache := lru.MustNewExpirable[string, int](3, time.Hour)\n\n\t// Add items to the cache\n\tcache.Set(\"one\", 1)\n\tcache.Set(\"two\", 2)\n\tcache.Set(\"three\", 3)\n"}}
{"type":"user","timestamp":"2025-12-29T19:43:28.986Z","content":"ok add a nil check then. If it's nil, we set it to time.Now as it was originally meant to be"}
{"type":"tool_use","timestamp":"2025-12-29T19:43:38.505Z","tool_name":"read","tool_input":{"filePath":"/Users/rselbach/devel/lru/expirable.go","offset":390,"limit":30}}
{"type":"tool_result","timestamp":"2025-12-29T19:43:38.507Z","tool_name":"read","tool_input":{"filePath":"/Users/rselbach/devel/lru/expirable.go","offset":390,"limit":30},"tool_output":{"preview":"\tc.ttl = ttl\n\treturn nil\n}\n\n// OnEvict sets a callback function that will be called when an entry is evicted from the cache.\n// The callback will receive the key and value of the evicted entry.\n// This includes both manual removals and automatic evictions due to capacity or expiry.\nfunc (c *Expirable[K, V]) OnEvict(f OnEvictFunc[K, V]) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tc.onEvict = f\n}\n\n// removeExpiredLocked removes all expired items from the cache.\n// it assumes the mutex is already locked.\n// Returns a slice of expired entries for callback invocation outside the lock.\nfunc (c *Expirable[K, V]) removeExpiredLocked() []expirableEntry[K, V] {\n\tnow := c.timeNow()\n\tvar expired []expirableEntry[K, V]"}}
{"type":"tool_use","timestamp":"2025-12-29T19:43:49.925Z","tool_name":"edit","tool_input":{"filePath":"/Users/rselbach/devel/lru/expirable.go","oldString":"// OnEvict sets a callback function that will be called when an entry is evicted from the cache.\n// The callback will receive the key and value of the evicted entry.\n// This includes both manual removals and automatic evictions due to capacity or expiry.\nfunc (c *Expirable[K, V]) OnEvict(f OnEvictFunc[K, V]) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tc.onEvict = f\n}\n\n// removeExpiredLocked removes all expired items from the cache.","newString":"// OnEvict sets a callback function that will be called when an entry is evicted from the cache.\n// The callback will receive the key and value of the evicted entry.\n// This includes both manual removals and automatic evictions due to capacity or expiry.\nfunc (c *Expirable[K, V]) OnEvict(f OnEvictFunc[K, V]) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tc.onEvict = f\n}\n\n// SetTimeNowFunc replaces the function used to get the current time.\n// This is primarily useful for testing. Passing nil resets to time.Now.\nfunc (c *Expirable[K, V]) SetTimeNowFunc(f func() time.Time) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif f == nil {\n\t\tf = time.Now\n\t}\n\tc.timeNow = f\n}\n\n// removeExpiredLocked removes all expired items from the cache."}}
{"type":"tool_result","timestamp":"2025-12-29T19:43:50.095Z","tool_name":"edit","tool_input":{"filePath":"/Users/rselbach/devel/lru/expirable.go","oldString":"// OnEvict sets a callback function that will be called when an entry is evicted from the cache.\n// The callback will receive the key and value of the evicted entry.\n// This includes both manual removals and automatic evictions due to capacity or expiry.\nfunc (c *Expirable[K, V]) OnEvict(f OnEvictFunc[K, V]) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tc.onEvict = f\n}\n\n// removeExpiredLocked removes all expired items from the cache.","newString":"// OnEvict sets a callback function that will be called when an entry is evicted from the cache.\n// The callback will receive the key and value of the evicted entry.\n// This includes both manual removals and automatic evictions due to capacity or expiry.\nfunc (c *Expirable[K, V]) OnEvict(f OnEvictFunc[K, V]) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tc.onEvict = f\n}\n\n// SetTimeNowFunc replaces the function used to get the current time.\n// This is primarily useful for testing. Passing nil resets to time.Now.\nfunc (c *Expirable[K, V]) SetTimeNowFunc(f func() time.Time) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif f == nil {\n\t\tf = time.Now\n\t}\n\tc.timeNow = f\n}\n\n// removeExpiredLocked removes all expired items from the cache."},"tool_output":{"diagnostics":{"/Users/rselbach/devel/lru/lru.go":[],"/Users/rselbach/devel/lru/expirable.go":[],"/Users/rselbach/devel/lru/lru_test.go":[],"/Users/rselbach/devel/lru/expirable_test.go":[],"/Users/rselbach/devel/lru/callbacks_test.go":[],"/Users/rselbach/devel/lru/expirable_example_test.go":[{"range":{"start":{"line":49,"character":7},"end":{"line":49,"character":21}},"severity":1,"code":"MissingFieldOrMethod","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#MissingFieldOrMethod"},"source":"compiler","message":"cache.SetTimeNowFunc undefined (type *lru.Expirable[string, string] has no field or method SetTimeNowFunc)"},{"range":{"start":{"line":116,"character":7},"end":{"line":116,"character":21}},"severity":1,"code":"MissingFieldOrMethod","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#MissingFieldOrMethod"},"source":"compiler","message":"cache.SetTimeNowFunc undefined (type *lru.Expirable[string, string] has no field or method SetTimeNowFunc)"},{"range":{"start":{"line":168,"character":8},"end":{"line":168,"character":22}},"severity":1,"code":"MissingFieldOrMethod","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#MissingFieldOrMethod"},"source":"compiler","message":"cache.SetTimeNowFunc undefined (type *lru.Expirable[string, int] has no field or method SetTimeNowFunc)"}]},"diff":"Index: /Users/rselbach/devel/lru/expirable.go\n===================================================================\n--- /Users/rselbach/devel/lru/expirable.go\n+++ /Users/rselbach/devel/lru/expirable.go\n@@ -401,8 +401,20 @@\n \n \tc.onEvict = f\n }\n \n+// SetTimeNowFunc replaces the function used to get the current time.\n+// This is primarily useful for testing. Passing nil resets to time.Now.\n+func (c *Expirable[K, V]) SetTimeNowFunc(f func() time.Time) {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\n+\tif f == nil {\n+\t\tf = time.Now\n+\t}\n+\tc.timeNow = f\n+}\n+\n // removeExpiredLocked removes all expired items from the cache.\n // it assumes the mutex is already locked.\n // Returns a slice of expired entries for callback invocation outside the lock.\n func (c *Expirable[K, V]) removeExpiredLocked() []expirableEntry[K, V] {\n","filediff":{"file":"/Users/rselbach/devel/lru/expirable.go","before":"// Package lru provides a generic, thread-safe LRU cache implementation.\npackage lru\n\nimport (\n\t\"container/list\"\n\t\"errors\"\n\t\"sync\"\n\t\"time\"\n)\n\n// expirableEntry extends cacheEntry with an expiry time.\ntype expirableEntry[K comparable, V any] struct {\n\tkey    K\n\tval    V\n\texpiry time.Time\n}\n\n// Expirable represents a thread-safe, fixed-size LRU cache with expiry functionality.\ntype Expirable[K comparable, V any] struct {\n\tcapacity int\n\titems    map[K]*list.Element\n\tlruList  *list.List\n\tmu       sync.RWMutex\n\tttl      time.Duration\n\ttimeNow  func() time.Time  // for testing\n\tonEvict  OnEvictFunc[K, V] // callback for evictions\n}\n\n// NewExpirable creates a new LRU cache with the given capacity and TTL.\n// Items will be automatically removed from the cache when they expire.\n// The capacity must be greater than zero, and the TTL must be greater than zero.\nfunc NewExpirable[K comparable, V any](capacity int, ttl time.Duration) (*Expirable[K, V], error) {\n\tif capacity <= 0 {\n\t\treturn nil, errors.New(\"capacity must be greater than zero\")\n\t}\n\tif ttl <= 0 {\n\t\treturn nil, errors.New(\"TTL must be greater than zero\")\n\t}\n\n\treturn &Expirable[K, V]{\n\t\tcapacity: capacity,\n\t\titems:    make(map[K]*list.Element),\n\t\tlruList:  list.New(),\n\t\tttl:      ttl,\n\t\ttimeNow:  time.Now,\n\t}, nil\n}\n\n// MustNewExpirable creates a new LRU cache with the given capacity and TTL.\n// It panics if the capacity or TTL is less than or equal to zero.\nfunc MustNewExpirable[K comparable, V any](capacity int, ttl time.Duration) *Expirable[K, V] {\n\tcache, err := NewExpirable[K, V](capacity, ttl)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn cache\n}\n\n// Get retrieves a value from the cache by key.\n// It returns the value and a boolean indicating whether the key was found and not expired.\n// This method also updates the item's position in the LRU list.\n// Expired items are removed when accessed.\nfunc (c *Expirable[K, V]) Get(key K) (V, bool) {\n\tc.mu.Lock()\n\n\tvar zero V\n\n\telement, found := c.items[key]\n\tif !found {\n\t\tc.mu.Unlock()\n\t\treturn zero, false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\n\t// check if the entry has expired\n\tif c.timeNow().After(entry.expiry) {\n\t\tevictedKey := entry.key\n\t\tevictedVal := entry.val\n\t\tonEvict := c.onEvict\n\t\tdelete(c.items, entry.key)\n\t\tc.lruList.Remove(element)\n\t\tc.mu.Unlock()\n\n\t\tif onEvict != nil {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t\treturn zero, false\n\t}\n\n\t// move to front of list to mark as recently used\n\tc.lruList.MoveToFront(element)\n\tval := entry.val\n\tc.mu.Unlock()\n\n\treturn val, true\n}\n\n// GetWithTTL retrieves a value and its remaining TTL from the cache by key.\n// It returns the value, remaining TTL, and a boolean indicating whether the key was found and not expired.\n// Expired items are removed when accessed.\nfunc (c *Expirable[K, V]) GetWithTTL(key K) (V, time.Duration, bool) {\n\tc.mu.Lock()\n\n\tvar zero V\n\n\telement, found := c.items[key]\n\tif !found {\n\t\tc.mu.Unlock()\n\t\treturn zero, 0, false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\n\tnow := c.timeNow()\n\t// check if the entry has expired\n\tif now.After(entry.expiry) {\n\t\tevictedKey := entry.key\n\t\tevictedVal := entry.val\n\t\tonEvict := c.onEvict\n\t\tdelete(c.items, entry.key)\n\t\tc.lruList.Remove(element)\n\t\tc.mu.Unlock()\n\n\t\tif onEvict != nil {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t\treturn zero, 0, false\n\t}\n\n\t// move to front of list to mark as recently used\n\tc.lruList.MoveToFront(element)\n\n\t// calculate remaining TTL\n\tttl := entry.expiry.Sub(now)\n\tif ttl < 0 {\n\t\tttl = 0\n\t}\n\tval := entry.val\n\tc.mu.Unlock()\n\n\treturn val, ttl, true\n}\n\n// GetOrSet retrieves a value from the cache by key, or computes and sets it if not present or expired.\n// The compute function is only called if the key is not present in the cache or is expired.\n// Note: if multiple goroutines call GetOrSet concurrently for the same missing/expired key,\n// compute may be called multiple times but only one result will be cached.\nfunc (c *Expirable[K, V]) GetOrSet(key K, compute func() (V, error)) (V, error) {\n\t// first try to get the item without a write lock\n\tif val, found := c.Get(key); found {\n\t\treturn val, nil\n\t}\n\n\t// compute the value outside the lock to avoid deadlock if compute\n\t// calls back into the cache\n\tval, err := compute()\n\tif err != nil {\n\t\tvar zero V\n\t\treturn zero, err\n\t}\n\n\tc.mu.Lock()\n\t// check again in case it was added while we were computing\n\telement, found := c.items[key]\n\tvar expiredEntry *expirableEntry[K, V]\n\tif found {\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif !c.timeNow().After(entry.expiry) {\n\t\t\tc.lruList.MoveToFront(element)\n\t\t\tval := entry.val\n\t\t\tc.mu.Unlock()\n\t\t\treturn val, nil\n\t\t}\n\t\t// expired entry, remove it and save for callback\n\t\texpiredEntry = entry\n\t\tdelete(c.items, key)\n\t\tc.lruList.Remove(element)\n\t}\n\n\t// add to cache\n\tevictedKey, evictedVal, hasEvicted := c.setLocked(key, val)\n\tonEvict := c.onEvict\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tif expiredEntry != nil {\n\t\t\tonEvict(expiredEntry.key, expiredEntry.val)\n\t\t}\n\t\tif hasEvicted {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t}\n\treturn val, nil\n}\n\n// Set adds or updates an item in the cache.\n// If the key already exists, its value is updated.\n// If the cache is at capacity, the least recently used item is evicted.\n// Any expired items are automatically removed when adding a new item.\nfunc (c *Expirable[K, V]) Set(key K, value V) {\n\tc.mu.Lock()\n\texpired := c.removeExpiredLocked()\n\tevictedKey, evictedVal, hasEvicted := c.setLocked(key, value)\n\tonEvict := c.onEvict\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tfor _, entry := range expired {\n\t\t\tonEvict(entry.key, entry.val)\n\t\t}\n\t\tif hasEvicted {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t}\n}\n\n// setLocked is an internal method that adds or updates an item in the cache.\n// it assumes the mutex is already locked and expired items have been removed.\n// Returns the evicted key/value and whether an eviction occurred.\nfunc (c *Expirable[K, V]) setLocked(key K, value V) (evictedKey K, evictedVal V, evicted bool) {\n\t// if key exists, update value and expiry and move to front\n\tif element, found := c.items[key]; found {\n\t\tc.lruList.MoveToFront(element)\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tentry.val = value\n\t\tentry.expiry = c.timeNow().Add(c.ttl)\n\t\treturn\n\t}\n\n\t// if we're at capacity, remove the least recently used item\n\tif c.lruList.Len() >= c.capacity {\n\t\toldest := c.lruList.Back()\n\t\tif oldest != nil {\n\t\t\tentry := oldest.Value.(*expirableEntry[K, V])\n\t\t\tevictedKey = entry.key\n\t\t\tevictedVal = entry.val\n\t\t\tevicted = true\n\t\t\tdelete(c.items, entry.key)\n\t\t\tc.lruList.Remove(oldest)\n\t\t}\n\t}\n\n\t// add new item\n\tentry := &expirableEntry[K, V]{\n\t\tkey:    key,\n\t\tval:    value,\n\t\texpiry: c.timeNow().Add(c.ttl),\n\t}\n\telement := c.lruList.PushFront(entry)\n\tc.items[key] = element\n\treturn\n}\n\n// Remove deletes an item from the cache by key.\n// It returns whether the key was found and removed.\nfunc (c *Expirable[K, V]) Remove(key K) bool {\n\tc.mu.Lock()\n\texpired := c.removeExpiredLocked()\n\n\telement, found := c.items[key]\n\tif !found {\n\t\tonEvict := c.onEvict\n\t\tc.mu.Unlock()\n\t\tif onEvict != nil {\n\t\t\tfor _, entry := range expired {\n\t\t\t\tonEvict(entry.key, entry.val)\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\tevictedKey := entry.key\n\tevictedVal := entry.val\n\tonEvict := c.onEvict\n\n\tdelete(c.items, key)\n\tc.lruList.Remove(element)\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tfor _, e := range expired {\n\t\t\tonEvict(e.key, e.val)\n\t\t}\n\t\tonEvict(evictedKey, evictedVal)\n\t}\n\treturn true\n}\n\n// Len returns the current number of non-expired items in the cache.\nfunc (c *Expirable[K, V]) Len() int {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\t// we'll need to count non-expired entries\n\tcount := 0\n\tnow := c.timeNow()\n\n\tfor _, element := range c.items {\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif !now.After(entry.expiry) {\n\t\t\tcount++\n\t\t}\n\t}\n\n\treturn count\n}\n\n// Clear removes all items from the cache.\nfunc (c *Expirable[K, V]) Clear() {\n\tc.mu.Lock()\n\tonEvict := c.onEvict\n\n\tvar evicted []expirableEntry[K, V]\n\tif onEvict != nil {\n\t\tnow := c.timeNow()\n\t\tevicted = make([]expirableEntry[K, V], 0, c.lruList.Len())\n\t\tfor element := c.lruList.Front(); element != nil; element = element.Next() {\n\t\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\t\tif !now.After(entry.expiry) {\n\t\t\t\tevicted = append(evicted, *entry)\n\t\t\t}\n\t\t}\n\t}\n\n\tc.items = make(map[K]*list.Element)\n\tc.lruList = list.New()\n\tc.mu.Unlock()\n\n\tfor _, entry := range evicted {\n\t\tonEvict(entry.key, entry.val)\n\t}\n}\n\n// Contains checks if a key exists in the cache and is not expired.\nfunc (c *Expirable[K, V]) Contains(key K) bool {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\telement, found := c.items[key]\n\tif !found {\n\t\treturn false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\treturn !c.timeNow().After(entry.expiry)\n}\n\n// Keys returns a slice of all keys in the cache that haven't expired.\n// The order is from most recently used to least recently used.\nfunc (c *Expirable[K, V]) Keys() []K {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tnow := c.timeNow()\n\tkeys := make([]K, 0, len(c.items))\n\n\tfor element := c.lruList.Front(); element != nil; element = element.Next() {\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif !now.After(entry.expiry) {\n\t\t\tkeys = append(keys, entry.key)\n\t\t}\n\t}\n\n\treturn keys\n}\n\n// Capacity returns the maximum capacity of the cache.\nfunc (c *Expirable[K, V]) Capacity() int {\n\treturn c.capacity\n}\n\n// TTL returns the time-to-live duration for cache entries.\nfunc (c *Expirable[K, V]) TTL() time.Duration {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\treturn c.ttl\n}\n\n// SetTTL updates the TTL for future cache entries.\n// It does not affect existing entries.\nfunc (c *Expirable[K, V]) SetTTL(ttl time.Duration) error {\n\tif ttl <= 0 {\n\t\treturn errors.New(\"TTL must be greater than zero\")\n\t}\n\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tc.ttl = ttl\n\treturn nil\n}\n\n// OnEvict sets a callback function that will be called when an entry is evicted from the cache.\n// The callback will receive the key and value of the evicted entry.\n// This includes both manual removals and automatic evictions due to capacity or expiry.\nfunc (c *Expirable[K, V]) OnEvict(f OnEvictFunc[K, V]) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tc.onEvict = f\n}\n\n// removeExpiredLocked removes all expired items from the cache.\n// it assumes the mutex is already locked.\n// Returns a slice of expired entries for callback invocation outside the lock.\nfunc (c *Expirable[K, V]) removeExpiredLocked() []expirableEntry[K, V] {\n\tnow := c.timeNow()\n\tvar expired []expirableEntry[K, V]\n\n\tfor element := c.lruList.Front(); element != nil; {\n\t\tnextElement := element.Next()\n\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif now.After(entry.expiry) {\n\t\t\texpired = append(expired, *entry)\n\t\t\tdelete(c.items, entry.key)\n\t\t\tc.lruList.Remove(element)\n\t\t}\n\n\t\telement = nextElement\n\t}\n\treturn expired\n}\n\n// RemoveExpired explicitly removes all expired items from the cache.\n// Returns the number of items removed.\n// This method will call the eviction callback for each expired item if one is set.\nfunc (c *Expirable[K, V]) RemoveExpired() int {\n\tc.mu.Lock()\n\n\tnow := c.timeNow()\n\tremoved := 0\n\n\texpiredItems := make([]K, 0)\n\texpiredValues := make([]V, 0)\n\n\tfor element := c.lruList.Front(); element != nil; {\n\t\tnextElement := element.Next()\n\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif now.After(entry.expiry) {\n\t\t\texpiredItems = append(expiredItems, entry.key)\n\t\t\texpiredValues = append(expiredValues, entry.val)\n\t\t\tdelete(c.items, entry.key)\n\t\t\tc.lruList.Remove(element)\n\t\t\tremoved++\n\t\t}\n\n\t\telement = nextElement\n\t}\n\n\tonEvict := c.onEvict\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tfor i := range expiredItems {\n\t\t\tonEvict(expiredItems[i], expiredValues[i])\n\t\t}\n\t}\n\n\treturn removed\n}\n","after":"// Package lru provides a generic, thread-safe LRU cache implementation.\npackage lru\n\nimport (\n\t\"container/list\"\n\t\"errors\"\n\t\"sync\"\n\t\"time\"\n)\n\n// expirableEntry extends cacheEntry with an expiry time.\ntype expirableEntry[K comparable, V any] struct {\n\tkey    K\n\tval    V\n\texpiry time.Time\n}\n\n// Expirable represents a thread-safe, fixed-size LRU cache with expiry functionality.\ntype Expirable[K comparable, V any] struct {\n\tcapacity int\n\titems    map[K]*list.Element\n\tlruList  *list.List\n\tmu       sync.RWMutex\n\tttl      time.Duration\n\ttimeNow  func() time.Time  // for testing\n\tonEvict  OnEvictFunc[K, V] // callback for evictions\n}\n\n// NewExpirable creates a new LRU cache with the given capacity and TTL.\n// Items will be automatically removed from the cache when they expire.\n// The capacity must be greater than zero, and the TTL must be greater than zero.\nfunc NewExpirable[K comparable, V any](capacity int, ttl time.Duration) (*Expirable[K, V], error) {\n\tif capacity <= 0 {\n\t\treturn nil, errors.New(\"capacity must be greater than zero\")\n\t}\n\tif ttl <= 0 {\n\t\treturn nil, errors.New(\"TTL must be greater than zero\")\n\t}\n\n\treturn &Expirable[K, V]{\n\t\tcapacity: capacity,\n\t\titems:    make(map[K]*list.Element),\n\t\tlruList:  list.New(),\n\t\tttl:      ttl,\n\t\ttimeNow:  time.Now,\n\t}, nil\n}\n\n// MustNewExpirable creates a new LRU cache with the given capacity and TTL.\n// It panics if the capacity or TTL is less than or equal to zero.\nfunc MustNewExpirable[K comparable, V any](capacity int, ttl time.Duration) *Expirable[K, V] {\n\tcache, err := NewExpirable[K, V](capacity, ttl)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn cache\n}\n\n// Get retrieves a value from the cache by key.\n// It returns the value and a boolean indicating whether the key was found and not expired.\n// This method also updates the item's position in the LRU list.\n// Expired items are removed when accessed.\nfunc (c *Expirable[K, V]) Get(key K) (V, bool) {\n\tc.mu.Lock()\n\n\tvar zero V\n\n\telement, found := c.items[key]\n\tif !found {\n\t\tc.mu.Unlock()\n\t\treturn zero, false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\n\t// check if the entry has expired\n\tif c.timeNow().After(entry.expiry) {\n\t\tevictedKey := entry.key\n\t\tevictedVal := entry.val\n\t\tonEvict := c.onEvict\n\t\tdelete(c.items, entry.key)\n\t\tc.lruList.Remove(element)\n\t\tc.mu.Unlock()\n\n\t\tif onEvict != nil {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t\treturn zero, false\n\t}\n\n\t// move to front of list to mark as recently used\n\tc.lruList.MoveToFront(element)\n\tval := entry.val\n\tc.mu.Unlock()\n\n\treturn val, true\n}\n\n// GetWithTTL retrieves a value and its remaining TTL from the cache by key.\n// It returns the value, remaining TTL, and a boolean indicating whether the key was found and not expired.\n// Expired items are removed when accessed.\nfunc (c *Expirable[K, V]) GetWithTTL(key K) (V, time.Duration, bool) {\n\tc.mu.Lock()\n\n\tvar zero V\n\n\telement, found := c.items[key]\n\tif !found {\n\t\tc.mu.Unlock()\n\t\treturn zero, 0, false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\n\tnow := c.timeNow()\n\t// check if the entry has expired\n\tif now.After(entry.expiry) {\n\t\tevictedKey := entry.key\n\t\tevictedVal := entry.val\n\t\tonEvict := c.onEvict\n\t\tdelete(c.items, entry.key)\n\t\tc.lruList.Remove(element)\n\t\tc.mu.Unlock()\n\n\t\tif onEvict != nil {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t\treturn zero, 0, false\n\t}\n\n\t// move to front of list to mark as recently used\n\tc.lruList.MoveToFront(element)\n\n\t// calculate remaining TTL\n\tttl := entry.expiry.Sub(now)\n\tif ttl < 0 {\n\t\tttl = 0\n\t}\n\tval := entry.val\n\tc.mu.Unlock()\n\n\treturn val, ttl, true\n}\n\n// GetOrSet retrieves a value from the cache by key, or computes and sets it if not present or expired.\n// The compute function is only called if the key is not present in the cache or is expired.\n// Note: if multiple goroutines call GetOrSet concurrently for the same missing/expired key,\n// compute may be called multiple times but only one result will be cached.\nfunc (c *Expirable[K, V]) GetOrSet(key K, compute func() (V, error)) (V, error) {\n\t// first try to get the item without a write lock\n\tif val, found := c.Get(key); found {\n\t\treturn val, nil\n\t}\n\n\t// compute the value outside the lock to avoid deadlock if compute\n\t// calls back into the cache\n\tval, err := compute()\n\tif err != nil {\n\t\tvar zero V\n\t\treturn zero, err\n\t}\n\n\tc.mu.Lock()\n\t// check again in case it was added while we were computing\n\telement, found := c.items[key]\n\tvar expiredEntry *expirableEntry[K, V]\n\tif found {\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif !c.timeNow().After(entry.expiry) {\n\t\t\tc.lruList.MoveToFront(element)\n\t\t\tval := entry.val\n\t\t\tc.mu.Unlock()\n\t\t\treturn val, nil\n\t\t}\n\t\t// expired entry, remove it and save for callback\n\t\texpiredEntry = entry\n\t\tdelete(c.items, key)\n\t\tc.lruList.Remove(element)\n\t}\n\n\t// add to cache\n\tevictedKey, evictedVal, hasEvicted := c.setLocked(key, val)\n\tonEvict := c.onEvict\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tif expiredEntry != nil {\n\t\t\tonEvict(expiredEntry.key, expiredEntry.val)\n\t\t}\n\t\tif hasEvicted {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t}\n\treturn val, nil\n}\n\n// Set adds or updates an item in the cache.\n// If the key already exists, its value is updated.\n// If the cache is at capacity, the least recently used item is evicted.\n// Any expired items are automatically removed when adding a new item.\nfunc (c *Expirable[K, V]) Set(key K, value V) {\n\tc.mu.Lock()\n\texpired := c.removeExpiredLocked()\n\tevictedKey, evictedVal, hasEvicted := c.setLocked(key, value)\n\tonEvict := c.onEvict\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tfor _, entry := range expired {\n\t\t\tonEvict(entry.key, entry.val)\n\t\t}\n\t\tif hasEvicted {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t}\n}\n\n// setLocked is an internal method that adds or updates an item in the cache.\n// it assumes the mutex is already locked and expired items have been removed.\n// Returns the evicted key/value and whether an eviction occurred.\nfunc (c *Expirable[K, V]) setLocked(key K, value V) (evictedKey K, evictedVal V, evicted bool) {\n\t// if key exists, update value and expiry and move to front\n\tif element, found := c.items[key]; found {\n\t\tc.lruList.MoveToFront(element)\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tentry.val = value\n\t\tentry.expiry = c.timeNow().Add(c.ttl)\n\t\treturn\n\t}\n\n\t// if we're at capacity, remove the least recently used item\n\tif c.lruList.Len() >= c.capacity {\n\t\toldest := c.lruList.Back()\n\t\tif oldest != nil {\n\t\t\tentry := oldest.Value.(*expirableEntry[K, V])\n\t\t\tevictedKey = entry.key\n\t\t\tevictedVal = entry.val\n\t\t\tevicted = true\n\t\t\tdelete(c.items, entry.key)\n\t\t\tc.lruList.Remove(oldest)\n\t\t}\n\t}\n\n\t// add new item\n\tentry := &expirableEntry[K, V]{\n\t\tkey:    key,\n\t\tval:    value,\n\t\texpiry: c.timeNow().Add(c.ttl),\n\t}\n\telement := c.lruList.PushFront(entry)\n\tc.items[key] = element\n\treturn\n}\n\n// Remove deletes an item from the cache by key.\n// It returns whether the key was found and removed.\nfunc (c *Expirable[K, V]) Remove(key K) bool {\n\tc.mu.Lock()\n\texpired := c.removeExpiredLocked()\n\n\telement, found := c.items[key]\n\tif !found {\n\t\tonEvict := c.onEvict\n\t\tc.mu.Unlock()\n\t\tif onEvict != nil {\n\t\t\tfor _, entry := range expired {\n\t\t\t\tonEvict(entry.key, entry.val)\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\tevictedKey := entry.key\n\tevictedVal := entry.val\n\tonEvict := c.onEvict\n\n\tdelete(c.items, key)\n\tc.lruList.Remove(element)\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tfor _, e := range expired {\n\t\t\tonEvict(e.key, e.val)\n\t\t}\n\t\tonEvict(evictedKey, evictedVal)\n\t}\n\treturn true\n}\n\n// Len returns the current number of non-expired items in the cache.\nfunc (c *Expirable[K, V]) Len() int {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\t// we'll need to count non-expired entries\n\tcount := 0\n\tnow := c.timeNow()\n\n\tfor _, element := range c.items {\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif !now.After(entry.expiry) {\n\t\t\tcount++\n\t\t}\n\t}\n\n\treturn count\n}\n\n// Clear removes all items from the cache.\nfunc (c *Expirable[K, V]) Clear() {\n\tc.mu.Lock()\n\tonEvict := c.onEvict\n\n\tvar evicted []expirableEntry[K, V]\n\tif onEvict != nil {\n\t\tnow := c.timeNow()\n\t\tevicted = make([]expirableEntry[K, V], 0, c.lruList.Len())\n\t\tfor element := c.lruList.Front(); element != nil; element = element.Next() {\n\t\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\t\tif !now.After(entry.expiry) {\n\t\t\t\tevicted = append(evicted, *entry)\n\t\t\t}\n\t\t}\n\t}\n\n\tc.items = make(map[K]*list.Element)\n\tc.lruList = list.New()\n\tc.mu.Unlock()\n\n\tfor _, entry := range evicted {\n\t\tonEvict(entry.key, entry.val)\n\t}\n}\n\n// Contains checks if a key exists in the cache and is not expired.\nfunc (c *Expirable[K, V]) Contains(key K) bool {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\telement, found := c.items[key]\n\tif !found {\n\t\treturn false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\treturn !c.timeNow().After(entry.expiry)\n}\n\n// Keys returns a slice of all keys in the cache that haven't expired.\n// The order is from most recently used to least recently used.\nfunc (c *Expirable[K, V]) Keys() []K {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tnow := c.timeNow()\n\tkeys := make([]K, 0, len(c.items))\n\n\tfor element := c.lruList.Front(); element != nil; element = element.Next() {\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif !now.After(entry.expiry) {\n\t\t\tkeys = append(keys, entry.key)\n\t\t}\n\t}\n\n\treturn keys\n}\n\n// Capacity returns the maximum capacity of the cache.\nfunc (c *Expirable[K, V]) Capacity() int {\n\treturn c.capacity\n}\n\n// TTL returns the time-to-live duration for cache entries.\nfunc (c *Expirable[K, V]) TTL() time.Duration {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\treturn c.ttl\n}\n\n// SetTTL updates the TTL for future cache entries.\n// It does not affect existing entries.\nfunc (c *Expirable[K, V]) SetTTL(ttl time.Duration) error {\n\tif ttl <= 0 {\n\t\treturn errors.New(\"TTL must be greater than zero\")\n\t}\n\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tc.ttl = ttl\n\treturn nil\n}\n\n// OnEvict sets a callback function that will be called when an entry is evicted from the cache.\n// The callback will receive the key and value of the evicted entry.\n// This includes both manual removals and automatic evictions due to capacity or expiry.\nfunc (c *Expirable[K, V]) OnEvict(f OnEvictFunc[K, V]) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tc.onEvict = f\n}\n\n// SetTimeNowFunc replaces the function used to get the current time.\n// This is primarily useful for testing. Passing nil resets to time.Now.\nfunc (c *Expirable[K, V]) SetTimeNowFunc(f func() time.Time) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif f == nil {\n\t\tf = time.Now\n\t}\n\tc.timeNow = f\n}\n\n// removeExpiredLocked removes all expired items from the cache.\n// it assumes the mutex is already locked.\n// Returns a slice of expired entries for callback invocation outside the lock.\nfunc (c *Expirable[K, V]) removeExpiredLocked() []expirableEntry[K, V] {\n\tnow := c.timeNow()\n\tvar expired []expirableEntry[K, V]\n\n\tfor element := c.lruList.Front(); element != nil; {\n\t\tnextElement := element.Next()\n\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif now.After(entry.expiry) {\n\t\t\texpired = append(expired, *entry)\n\t\t\tdelete(c.items, entry.key)\n\t\t\tc.lruList.Remove(element)\n\t\t}\n\n\t\telement = nextElement\n\t}\n\treturn expired\n}\n\n// RemoveExpired explicitly removes all expired items from the cache.\n// Returns the number of items removed.\n// This method will call the eviction callback for each expired item if one is set.\nfunc (c *Expirable[K, V]) RemoveExpired() int {\n\tc.mu.Lock()\n\n\tnow := c.timeNow()\n\tremoved := 0\n\n\texpiredItems := make([]K, 0)\n\texpiredValues := make([]V, 0)\n\n\tfor element := c.lruList.Front(); element != nil; {\n\t\tnextElement := element.Next()\n\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif now.After(entry.expiry) {\n\t\t\texpiredItems = append(expiredItems, entry.key)\n\t\t\texpiredValues = append(expiredValues, entry.val)\n\t\t\tdelete(c.items, entry.key)\n\t\t\tc.lruList.Remove(element)\n\t\t\tremoved++\n\t\t}\n\n\t\telement = nextElement\n\t}\n\n\tonEvict := c.onEvict\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tfor i := range expiredItems {\n\t\t\tonEvict(expiredItems[i], expiredValues[i])\n\t\t}\n\t}\n\n\treturn removed\n}\n","additions":12,"deletions":0}}}
{"type":"tool_use","timestamp":"2025-12-29T19:44:01.162Z","tool_name":"bash","tool_input":{"command":"cd /Users/rselbach/devel/lru && go test -race ./...","description":"Run tests to verify changes"}}
{"type":"tool_result","timestamp":"2025-12-29T19:44:03.979Z","tool_name":"bash","tool_input":{"command":"cd /Users/rselbach/devel/lru && go test -race ./...","description":"Run tests to verify changes","env":{"CI":"true","DEBIAN_FRONTEND":"noninteractive","GIT_TERMINAL_PROMPT":"0","GCM_INTERACTIVE":"never","HOMEBREW_NO_AUTO_UPDATE":"1","GIT_EDITOR":"true","EDITOR":"true","VISUAL":"true","GIT_SEQUENCE_EDITOR":"true","GIT_PAGER":"cat","PAGER":"cat","npm_config_yes":"true","PIP_NO_INPUT":"1","YARN_ENABLE_IMMUTABLE_INSTALLS":"false"}},"tool_output":{"output":"ok  \tgithub.com/rselbach/lru\t2.407s\n","exit":0,"description":"Run tests to verify changes"}}
{"type":"user","timestamp":"2025-12-29T19:45:10.764Z","content":"good job. Now let's improve our godoc. Instead of all the examples we have in the README, let's have those as part of godoc. You can create a doc.go for the intro part. "}
{"type":"tool_use","timestamp":"2025-12-29T19:45:20.500Z","tool_name":"read","tool_input":{"filePath":"/Users/rselbach/devel/lru/README.md"}}
{"type":"tool_result","timestamp":"2025-12-29T19:45:20.504Z","tool_name":"read","tool_input":{"filePath":"/Users/rselbach/devel/lru/README.md"},"tool_output":{"preview":"# Generic LRU Cache for Go\n\nA thread-safe, generic Least Recently Used (LRU) cache implementation in Go, with optional time-to-live functionality and eviction callbacks.\n\n## Features\n\n- Generic implementation using Go generics (requires Go 1.18+)\n- Efficient key-value lookups with O(1) complexity\n- Thread-safe operations (supports concurrent access)\n- Configurable capacity\n- Automatic eviction of least recently used items when capacity is reached\n- Comprehensive API for common cache operations\n- Optional time-based expiry mechanism with configurable TTL\n- Eviction callbacks to notify when items are removed from the cache\n\n## Installation\n\n```shell\ngo get github.com/rselbach/lru\n```"}}
{"type":"tool_use","timestamp":"2025-12-29T19:45:21.120Z","tool_name":"read","tool_input":{"filePath":"/Users/rselbach/devel/lru/example_test.go"}}
{"type":"tool_result","timestamp":"2025-12-29T19:45:21.122Z","tool_name":"read","tool_input":{"filePath":"/Users/rselbach/devel/lru/example_test.go"},"tool_output":{"preview":"package lru_test\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\n\t\"github.com/rselbach/lru\"\n)\n\n// This example demonstrates basic usage of the LRU cache.\nfunc Example_basic() {\n\t// Create a new LRU cache with a capacity of 3 items\n\tcache := lru.MustNew[string, int](3)\n\n\t// Add items to the cache\n\tcache.Set(\"one\", 1)\n\tcache.Set(\"two\", 2)\n\tcache.Set(\"three\", 3)\n\n\t// Get an item from the cache"}}
{"type":"tool_use","timestamp":"2025-12-29T19:45:45.778Z","tool_name":"write","tool_input":{"filePath":"/Users/rselbach/devel/lru/doc.go","content":"// Package lru provides generic, thread-safe LRU cache implementations.\n//\n// Two cache types are provided:\n//\n//   - [Cache]: A standard LRU cache with fixed capacity\n//   - [Expirable]: An LRU cache with per-entry TTL expiration\n//\n// Both are safe for concurrent use and support eviction callbacks.\n//\n// # Basic Usage\n//\n// Create a cache and store values:\n//\n//\tcache := lru.MustNew[string, int](100)\n//\tcache.Set(\"key\", 42)\n//\tvalue, found := cache.Get(\"key\")\n//\n// # Memoization with GetOrSet\n//\n// Compute values on cache miss:\n//\n//\tresult, err := cache.GetOrSet(\"key\", func() (int, error) {\n//\t    return expensiveComputation()\n//\t})\n//\n// # Expirable Cache\n//\n// Create a cache where entries expire after a duration:\n//\n//\tcache := lru.MustNewExpirable[string, int](100, 5*time.Minute)\n//\tcache.Set(\"key\", 42)\n//\tvalue, ttl, found := cache.GetWithTTL(\"key\")\n//\n// Expired entries are removed lazily on access or during write operations.\n// Call [Expirable.RemoveExpired] to explicitly purge all expired entries.\n//\n// # Eviction Callbacks\n//\n// Register a callback to be notified when entries are evicted:\n//\n//\tcache.OnEvict(func(key string, value int) {\n//\t    fmt.Printf(\"evicted: %s=%d\\n\", key, value)\n//\t})\n//\n// Callbacks are invoked for capacity evictions, explicit removals via\n// [Cache.Remove], and [Cache.Clear]. For [Expirable.Clear], callbacks are\n// only invoked for entries that have not yet expired.\npackage lru\n"}}
{"type":"tool_result","timestamp":"2025-12-29T19:45:46.087Z","tool_name":"write","tool_input":{"filePath":"/Users/rselbach/devel/lru/doc.go","content":"// Package lru provides generic, thread-safe LRU cache implementations.\n//\n// Two cache types are provided:\n//\n//   - [Cache]: A standard LRU cache with fixed capacity\n//   - [Expirable]: An LRU cache with per-entry TTL expiration\n//\n// Both are safe for concurrent use and support eviction callbacks.\n//\n// # Basic Usage\n//\n// Create a cache and store values:\n//\n//\tcache := lru.MustNew[string, int](100)\n//\tcache.Set(\"key\", 42)\n//\tvalue, found := cache.Get(\"key\")\n//\n// # Memoization with GetOrSet\n//\n// Compute values on cache miss:\n//\n//\tresult, err := cache.GetOrSet(\"key\", func() (int, error) {\n//\t    return expensiveComputation()\n//\t})\n//\n// # Expirable Cache\n//\n// Create a cache where entries expire after a duration:\n//\n//\tcache := lru.MustNewExpirable[string, int](100, 5*time.Minute)\n//\tcache.Set(\"key\", 42)\n//\tvalue, ttl, found := cache.GetWithTTL(\"key\")\n//\n// Expired entries are removed lazily on access or during write operations.\n// Call [Expirable.RemoveExpired] to explicitly purge all expired entries.\n//\n// # Eviction Callbacks\n//\n// Register a callback to be notified when entries are evicted:\n//\n//\tcache.OnEvict(func(key string, value int) {\n//\t    fmt.Printf(\"evicted: %s=%d\\n\", key, value)\n//\t})\n//\n// Callbacks are invoked for capacity evictions, explicit removals via\n// [Cache.Remove], and [Cache.Clear]. For [Expirable.Clear], callbacks are\n// only invoked for entries that have not yet expired.\npackage lru\n"},"tool_output":{"diagnostics":{"/Users/rselbach/devel/lru/lru.go":[],"/Users/rselbach/devel/lru/expirable.go":[],"/Users/rselbach/devel/lru/lru_test.go":[],"/Users/rselbach/devel/lru/expirable_test.go":[],"/Users/rselbach/devel/lru/callbacks_test.go":[],"/Users/rselbach/devel/lru/expirable_example_test.go":[],"/Users/rselbach/devel/lru/example_test.go":[],"/Users/rselbach/devel/lru/doc.go":[]},"filepath":"/Users/rselbach/devel/lru/doc.go","exists":false}}
{"type":"tool_use","timestamp":"2025-12-29T19:45:57.977Z","tool_name":"bash","tool_input":{"command":"cd /Users/rselbach/devel/lru && go doc","description":"Verify godoc renders correctly"}}
{"type":"tool_result","timestamp":"2025-12-29T19:45:58.031Z","tool_name":"bash","tool_input":{"command":"cd /Users/rselbach/devel/lru && go doc","description":"Verify godoc renders correctly","env":{"CI":"true","DEBIAN_FRONTEND":"noninteractive","GIT_TERMINAL_PROMPT":"0","GCM_INTERACTIVE":"never","HOMEBREW_NO_AUTO_UPDATE":"1","GIT_EDITOR":"true","EDITOR":"true","VISUAL":"true","GIT_SEQUENCE_EDITOR":"true","GIT_PAGER":"cat","PAGER":"cat","npm_config_yes":"true","PIP_NO_INPUT":"1","YARN_ENABLE_IMMUTABLE_INSTALLS":"false"}},"tool_output":{"output":"package lru // import \"github.com/rselbach/lru\"\n\nPackage lru provides generic, thread-safe LRU cache implementations.\n\nTwo cache types are provided:\n\n  - Cache: A standard LRU cache with fixed capacity\n  - Expirable: An LRU cache with per-entry TTL expiration\n\nBoth are safe for concurrent use and support eviction callbacks.\n\n# Basic Usage\n\nCreate a cache and store values:\n\n    cache := lru.MustNew[string, int](100)\n    cache.Set(\"key\", 42)\n    value, found := cache.Get(\"key\")\n\n# Memoization with GetOrSet\n\nCompute values on cache miss:\n\n    result, err := cache.GetOrSet(\"key\", func() (int, error) {\n        return expensiveComputation()\n    })\n\n# Expirable Cache\n\nCreate a cache where entries expire after a duration:\n\n    cache := lru.MustNewExpirable[string, int](100, 5*time.Minute)\n    cache.Set(\"key\", 42)\n    value, ttl, found := cache.GetWithTTL(\"key\")\n\nExpired entries are removed lazily on access or during write operations.\nCall Expirable.RemoveExpired to explicitly purge all expired entries.\n\n# Eviction Callbacks\n\nRegister a callback to be notified when entries are evicted:\n\n    cache.OnEvict(func(key string, value int) {\n        fmt.Printf(\"evicted: %s=%d\\n\", key, value)\n    })\n\nCallbacks are invoked for capacity evictions, explicit removals via\nCache.Remove, and Cache.Clear. For Expirable.Clear, callbacks are only invoked\nfor entries that have not yet expired.\n\nPackage lru provides a generic, thread-safe LRU cache implementation.\n\nPackage lru provides a generic, thread-safe LRU cache implementation.\n\nvar ErrKeyNotFound = errors.New(\"key not found in cache\") ...\ntype Cache[K comparable, V any] struct{ ... }\n    func MustNew[K comparable, V any](capacity int) *Cache[K, V]\n    func New[K comparable, V any](capacity int) (*Cache[K, V], error)\ntype Expirable[K comparable, V any] struct{ ... }\n    func MustNewExpirable[K comparable, V any](capacity int, ttl time.Duration) *Expirable[K, V]\n    func NewExpirable[K comparable, V any](capacity int, ttl time.Duration) (*Expirable[K, V], error)\ntype OnEvictFunc[K comparable, V any] func(key K, value V)\n","exit":0,"description":"Verify godoc renders correctly"}}
{"type":"tool_use","timestamp":"2025-12-29T19:46:08.501Z","tool_name":"edit","tool_input":{"filePath":"/Users/rselbach/devel/lru/lru.go","oldString":"// Package lru provides a generic, thread-safe LRU cache implementation.\npackage lru","newString":"package lru"}}
{"type":"tool_result","timestamp":"2025-12-29T19:46:08.665Z","tool_name":"edit","tool_input":{"filePath":"/Users/rselbach/devel/lru/lru.go","oldString":"// Package lru provides a generic, thread-safe LRU cache implementation.\npackage lru","newString":"package lru"},"tool_output":{"diagnostics":{"/Users/rselbach/devel/lru/lru.go":[],"/Users/rselbach/devel/lru/expirable.go":[],"/Users/rselbach/devel/lru/lru_test.go":[],"/Users/rselbach/devel/lru/expirable_test.go":[],"/Users/rselbach/devel/lru/callbacks_test.go":[],"/Users/rselbach/devel/lru/expirable_example_test.go":[],"/Users/rselbach/devel/lru/example_test.go":[],"/Users/rselbach/devel/lru/doc.go":[]},"diff":"Index: /Users/rselbach/devel/lru/lru.go\n===================================================================\n--- /Users/rselbach/devel/lru/lru.go\n+++ /Users/rselbach/devel/lru/lru.go\n@@ -1,5 +1,4 @@\n-// Package lru provides a generic, thread-safe LRU cache implementation.\n package lru\n \n import (\n \t\"container/list\"\n","filediff":{"file":"/Users/rselbach/devel/lru/lru.go","before":"// Package lru provides a generic, thread-safe LRU cache implementation.\npackage lru\n\nimport (\n\t\"container/list\"\n\t\"errors\"\n\t\"sync\"\n)\n\n// Cache errors\nvar (\n\tErrKeyNotFound = errors.New(\"key not found in cache\")\n\tErrNilValue    = errors.New(\"nil value not allowed\")\n)\n\n// OnEvictFunc is a function that is called when an entry is evicted from the cache.\ntype OnEvictFunc[K comparable, V any] func(key K, value V)\n\n// Cache represents a thread-safe, fixed-size LRU cache.\ntype Cache[K comparable, V any] struct {\n\tcapacity int\n\titems    map[K]*list.Element\n\tlruList  *list.List\n\tmu       sync.RWMutex\n\tonEvict  OnEvictFunc[K, V] // callback for evictions\n}\n\n// cacheEntry is an internal representation of a cache entry.\ntype cacheEntry[K comparable, V any] struct {\n\tkey K\n\tval V\n}\n\n// New creates a new LRU cache with the given capacity.\n// The capacity must be greater than zero.\nfunc New[K comparable, V any](capacity int) (*Cache[K, V], error) {\n\tif capacity <= 0 {\n\t\treturn nil, errors.New(\"capacity must be greater than zero\")\n\t}\n\n\treturn &Cache[K, V]{\n\t\tcapacity: capacity,\n\t\titems:    make(map[K]*list.Element),\n\t\tlruList:  list.New(),\n\t}, nil\n}\n\n// MustNew creates a new LRU cache with the given capacity.\n// It panics if the capacity is less than or equal to zero.\nfunc MustNew[K comparable, V any](capacity int) *Cache[K, V] {\n\tcache, err := New[K, V](capacity)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn cache\n}\n\n// Get retrieves a value from the cache by key.\n// It returns the value and a boolean indicating whether the key was found.\n// This method also updates the item's position in the LRU list.\nfunc (c *Cache[K, V]) Get(key K) (V, bool) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tvar zero V\n\n\telement, found := c.items[key]\n\tif !found {\n\t\treturn zero, false\n\t}\n\n\t// move to front of list to mark as recently used\n\tc.lruList.MoveToFront(element)\n\tentry := element.Value.(*cacheEntry[K, V])\n\n\treturn entry.val, true\n}\n\n// GetOrSet retrieves a value from the cache by key, or computes and sets it if not present.\n// The compute function is only called if the key is not present in the cache.\n// Note: if multiple goroutines call GetOrSet concurrently for the same missing key,\n// compute may be called multiple times but only one result will be cached.\nfunc (c *Cache[K, V]) GetOrSet(key K, compute func() (V, error)) (V, error) {\n\t// first try to get the item without a write lock\n\tif val, found := c.Get(key); found {\n\t\treturn val, nil\n\t}\n\n\t// compute the value outside the lock to avoid deadlock if compute\n\t// calls back into the cache\n\tval, err := compute()\n\tif err != nil {\n\t\tvar zero V\n\t\treturn zero, err\n\t}\n\n\tc.mu.Lock()\n\t// check again in case it was added while we were computing\n\tif element, found := c.items[key]; found {\n\t\tc.lruList.MoveToFront(element)\n\t\tentry := element.Value.(*cacheEntry[K, V])\n\t\tc.mu.Unlock()\n\t\treturn entry.val, nil\n\t}\n\n\t// add to cache\n\tevictedKey, evictedVal, hasEvicted := c.setLocked(key, val)\n\tonEvict := c.onEvict\n\tc.mu.Unlock()\n\n\tif hasEvicted && onEvict != nil {\n\t\tonEvict(evictedKey, evictedVal)\n\t}\n\treturn val, nil\n}\n\n// Set adds or updates an item in the cache.\n// If the key already exists, its value is updated.\n// If the cache is at capacity, the least recently used item is evicted.\nfunc (c *Cache[K, V]) Set(key K, value V) {\n\tvar evictedKey K\n\tvar evictedVal V\n\tvar hasEvicted bool\n\n\tc.mu.Lock()\n\tevictedKey, evictedVal, hasEvicted = c.setLocked(key, value)\n\tonEvict := c.onEvict\n\tc.mu.Unlock()\n\n\tif hasEvicted && onEvict != nil {\n\t\tonEvict(evictedKey, evictedVal)\n\t}\n}\n\n// setLocked is an internal method that adds or updates an item in the cache.\n// it assumes the mutex is already locked.\n// Returns the evicted key/value and whether an eviction occurred.\nfunc (c *Cache[K, V]) setLocked(key K, value V) (evictedKey K, evictedVal V, evicted bool) {\n\t// if key exists, update value and move to front\n\tif element, found := c.items[key]; found {\n\t\tc.lruList.MoveToFront(element)\n\t\tentry := element.Value.(*cacheEntry[K, V])\n\t\tentry.val = value\n\t\treturn\n\t}\n\n\t// if we're at capacity, remove the least recently used item\n\tif c.lruList.Len() >= c.capacity {\n\t\toldest := c.lruList.Back()\n\t\tif oldest != nil {\n\t\t\tentry := oldest.Value.(*cacheEntry[K, V])\n\t\t\tevictedKey = entry.key\n\t\t\tevictedVal = entry.val\n\t\t\tevicted = true\n\t\t\tdelete(c.items, entry.key)\n\t\t\tc.lruList.Remove(oldest)\n\t\t}\n\t}\n\n\t// add new item\n\tentry := &cacheEntry[K, V]{\n\t\tkey: key,\n\t\tval: value,\n\t}\n\telement := c.lruList.PushFront(entry)\n\tc.items[key] = element\n\treturn\n}\n\n// Remove deletes an item from the cache by key.\n// It returns whether the key was found and removed.\nfunc (c *Cache[K, V]) Remove(key K) bool {\n\tc.mu.Lock()\n\telement, found := c.items[key]\n\tif !found {\n\t\tc.mu.Unlock()\n\t\treturn false\n\t}\n\n\tentry := element.Value.(*cacheEntry[K, V])\n\tevictedKey := entry.key\n\tevictedVal := entry.val\n\tonEvict := c.onEvict\n\n\tdelete(c.items, key)\n\tc.lruList.Remove(element)\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tonEvict(evictedKey, evictedVal)\n\t}\n\treturn true\n}\n\n// Len returns the current number of items in the cache.\nfunc (c *Cache[K, V]) Len() int {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\treturn len(c.items)\n}\n\n// Clear removes all items from the cache.\nfunc (c *Cache[K, V]) Clear() {\n\tc.mu.Lock()\n\tonEvict := c.onEvict\n\n\tvar evicted []cacheEntry[K, V]\n\tif onEvict != nil {\n\t\tevicted = make([]cacheEntry[K, V], 0, c.lruList.Len())\n\t\tfor element := c.lruList.Front(); element != nil; element = element.Next() {\n\t\t\tentry := element.Value.(*cacheEntry[K, V])\n\t\t\tevicted = append(evicted, *entry)\n\t\t}\n\t}\n\n\tc.items = make(map[K]*list.Element)\n\tc.lruList = list.New()\n\tc.mu.Unlock()\n\n\tfor _, entry := range evicted {\n\t\tonEvict(entry.key, entry.val)\n\t}\n}\n\n// Contains checks if a key exists in the cache.\nfunc (c *Cache[K, V]) Contains(key K) bool {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\t_, found := c.items[key]\n\treturn found\n}\n\n// Keys returns a slice of all keys in the cache.\n// The order is from most recently used to least recently used.\nfunc (c *Cache[K, V]) Keys() []K {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tkeys := make([]K, 0, len(c.items))\n\tfor element := c.lruList.Front(); element != nil; element = element.Next() {\n\t\tentry := element.Value.(*cacheEntry[K, V])\n\t\tkeys = append(keys, entry.key)\n\t}\n\n\treturn keys\n}\n\n// Capacity returns the maximum capacity of the cache.\nfunc (c *Cache[K, V]) Capacity() int {\n\treturn c.capacity\n}\n\n// OnEvict sets a callback function that will be called when an entry is evicted from the cache.\n// The callback will receive the key and value of the evicted entry.\nfunc (c *Cache[K, V]) OnEvict(f OnEvictFunc[K, V]) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tc.onEvict = f\n}\n","after":"package lru\n\nimport (\n\t\"container/list\"\n\t\"errors\"\n\t\"sync\"\n)\n\n// Cache errors\nvar (\n\tErrKeyNotFound = errors.New(\"key not found in cache\")\n\tErrNilValue    = errors.New(\"nil value not allowed\")\n)\n\n// OnEvictFunc is a function that is called when an entry is evicted from the cache.\ntype OnEvictFunc[K comparable, V any] func(key K, value V)\n\n// Cache represents a thread-safe, fixed-size LRU cache.\ntype Cache[K comparable, V any] struct {\n\tcapacity int\n\titems    map[K]*list.Element\n\tlruList  *list.List\n\tmu       sync.RWMutex\n\tonEvict  OnEvictFunc[K, V] // callback for evictions\n}\n\n// cacheEntry is an internal representation of a cache entry.\ntype cacheEntry[K comparable, V any] struct {\n\tkey K\n\tval V\n}\n\n// New creates a new LRU cache with the given capacity.\n// The capacity must be greater than zero.\nfunc New[K comparable, V any](capacity int) (*Cache[K, V], error) {\n\tif capacity <= 0 {\n\t\treturn nil, errors.New(\"capacity must be greater than zero\")\n\t}\n\n\treturn &Cache[K, V]{\n\t\tcapacity: capacity,\n\t\titems:    make(map[K]*list.Element),\n\t\tlruList:  list.New(),\n\t}, nil\n}\n\n// MustNew creates a new LRU cache with the given capacity.\n// It panics if the capacity is less than or equal to zero.\nfunc MustNew[K comparable, V any](capacity int) *Cache[K, V] {\n\tcache, err := New[K, V](capacity)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn cache\n}\n\n// Get retrieves a value from the cache by key.\n// It returns the value and a boolean indicating whether the key was found.\n// This method also updates the item's position in the LRU list.\nfunc (c *Cache[K, V]) Get(key K) (V, bool) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tvar zero V\n\n\telement, found := c.items[key]\n\tif !found {\n\t\treturn zero, false\n\t}\n\n\t// move to front of list to mark as recently used\n\tc.lruList.MoveToFront(element)\n\tentry := element.Value.(*cacheEntry[K, V])\n\n\treturn entry.val, true\n}\n\n// GetOrSet retrieves a value from the cache by key, or computes and sets it if not present.\n// The compute function is only called if the key is not present in the cache.\n// Note: if multiple goroutines call GetOrSet concurrently for the same missing key,\n// compute may be called multiple times but only one result will be cached.\nfunc (c *Cache[K, V]) GetOrSet(key K, compute func() (V, error)) (V, error) {\n\t// first try to get the item without a write lock\n\tif val, found := c.Get(key); found {\n\t\treturn val, nil\n\t}\n\n\t// compute the value outside the lock to avoid deadlock if compute\n\t// calls back into the cache\n\tval, err := compute()\n\tif err != nil {\n\t\tvar zero V\n\t\treturn zero, err\n\t}\n\n\tc.mu.Lock()\n\t// check again in case it was added while we were computing\n\tif element, found := c.items[key]; found {\n\t\tc.lruList.MoveToFront(element)\n\t\tentry := element.Value.(*cacheEntry[K, V])\n\t\tc.mu.Unlock()\n\t\treturn entry.val, nil\n\t}\n\n\t// add to cache\n\tevictedKey, evictedVal, hasEvicted := c.setLocked(key, val)\n\tonEvict := c.onEvict\n\tc.mu.Unlock()\n\n\tif hasEvicted && onEvict != nil {\n\t\tonEvict(evictedKey, evictedVal)\n\t}\n\treturn val, nil\n}\n\n// Set adds or updates an item in the cache.\n// If the key already exists, its value is updated.\n// If the cache is at capacity, the least recently used item is evicted.\nfunc (c *Cache[K, V]) Set(key K, value V) {\n\tvar evictedKey K\n\tvar evictedVal V\n\tvar hasEvicted bool\n\n\tc.mu.Lock()\n\tevictedKey, evictedVal, hasEvicted = c.setLocked(key, value)\n\tonEvict := c.onEvict\n\tc.mu.Unlock()\n\n\tif hasEvicted && onEvict != nil {\n\t\tonEvict(evictedKey, evictedVal)\n\t}\n}\n\n// setLocked is an internal method that adds or updates an item in the cache.\n// it assumes the mutex is already locked.\n// Returns the evicted key/value and whether an eviction occurred.\nfunc (c *Cache[K, V]) setLocked(key K, value V) (evictedKey K, evictedVal V, evicted bool) {\n\t// if key exists, update value and move to front\n\tif element, found := c.items[key]; found {\n\t\tc.lruList.MoveToFront(element)\n\t\tentry := element.Value.(*cacheEntry[K, V])\n\t\tentry.val = value\n\t\treturn\n\t}\n\n\t// if we're at capacity, remove the least recently used item\n\tif c.lruList.Len() >= c.capacity {\n\t\toldest := c.lruList.Back()\n\t\tif oldest != nil {\n\t\t\tentry := oldest.Value.(*cacheEntry[K, V])\n\t\t\tevictedKey = entry.key\n\t\t\tevictedVal = entry.val\n\t\t\tevicted = true\n\t\t\tdelete(c.items, entry.key)\n\t\t\tc.lruList.Remove(oldest)\n\t\t}\n\t}\n\n\t// add new item\n\tentry := &cacheEntry[K, V]{\n\t\tkey: key,\n\t\tval: value,\n\t}\n\telement := c.lruList.PushFront(entry)\n\tc.items[key] = element\n\treturn\n}\n\n// Remove deletes an item from the cache by key.\n// It returns whether the key was found and removed.\nfunc (c *Cache[K, V]) Remove(key K) bool {\n\tc.mu.Lock()\n\telement, found := c.items[key]\n\tif !found {\n\t\tc.mu.Unlock()\n\t\treturn false\n\t}\n\n\tentry := element.Value.(*cacheEntry[K, V])\n\tevictedKey := entry.key\n\tevictedVal := entry.val\n\tonEvict := c.onEvict\n\n\tdelete(c.items, key)\n\tc.lruList.Remove(element)\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tonEvict(evictedKey, evictedVal)\n\t}\n\treturn true\n}\n\n// Len returns the current number of items in the cache.\nfunc (c *Cache[K, V]) Len() int {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\treturn len(c.items)\n}\n\n// Clear removes all items from the cache.\nfunc (c *Cache[K, V]) Clear() {\n\tc.mu.Lock()\n\tonEvict := c.onEvict\n\n\tvar evicted []cacheEntry[K, V]\n\tif onEvict != nil {\n\t\tevicted = make([]cacheEntry[K, V], 0, c.lruList.Len())\n\t\tfor element := c.lruList.Front(); element != nil; element = element.Next() {\n\t\t\tentry := element.Value.(*cacheEntry[K, V])\n\t\t\tevicted = append(evicted, *entry)\n\t\t}\n\t}\n\n\tc.items = make(map[K]*list.Element)\n\tc.lruList = list.New()\n\tc.mu.Unlock()\n\n\tfor _, entry := range evicted {\n\t\tonEvict(entry.key, entry.val)\n\t}\n}\n\n// Contains checks if a key exists in the cache.\nfunc (c *Cache[K, V]) Contains(key K) bool {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\t_, found := c.items[key]\n\treturn found\n}\n\n// Keys returns a slice of all keys in the cache.\n// The order is from most recently used to least recently used.\nfunc (c *Cache[K, V]) Keys() []K {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tkeys := make([]K, 0, len(c.items))\n\tfor element := c.lruList.Front(); element != nil; element = element.Next() {\n\t\tentry := element.Value.(*cacheEntry[K, V])\n\t\tkeys = append(keys, entry.key)\n\t}\n\n\treturn keys\n}\n\n// Capacity returns the maximum capacity of the cache.\nfunc (c *Cache[K, V]) Capacity() int {\n\treturn c.capacity\n}\n\n// OnEvict sets a callback function that will be called when an entry is evicted from the cache.\n// The callback will receive the key and value of the evicted entry.\nfunc (c *Cache[K, V]) OnEvict(f OnEvictFunc[K, V]) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tc.onEvict = f\n}\n","additions":0,"deletions":1}}}
{"type":"tool_use","timestamp":"2025-12-29T19:46:09.168Z","tool_name":"edit","tool_input":{"filePath":"/Users/rselbach/devel/lru/expirable.go","oldString":"// Package lru provides a generic, thread-safe LRU cache implementation.\npackage lru","newString":"package lru"}}
{"type":"tool_result","timestamp":"2025-12-29T19:46:09.333Z","tool_name":"edit","tool_input":{"filePath":"/Users/rselbach/devel/lru/expirable.go","oldString":"// Package lru provides a generic, thread-safe LRU cache implementation.\npackage lru","newString":"package lru"},"tool_output":{"diagnostics":{"/Users/rselbach/devel/lru/lru.go":[],"/Users/rselbach/devel/lru/expirable.go":[],"/Users/rselbach/devel/lru/lru_test.go":[],"/Users/rselbach/devel/lru/expirable_test.go":[],"/Users/rselbach/devel/lru/callbacks_test.go":[],"/Users/rselbach/devel/lru/expirable_example_test.go":[],"/Users/rselbach/devel/lru/example_test.go":[],"/Users/rselbach/devel/lru/doc.go":[]},"diff":"Index: /Users/rselbach/devel/lru/expirable.go\n===================================================================\n--- /Users/rselbach/devel/lru/expirable.go\n+++ /Users/rselbach/devel/lru/expirable.go\n@@ -1,5 +1,4 @@\n-// Package lru provides a generic, thread-safe LRU cache implementation.\n package lru\n \n import (\n \t\"container/list\"\n","filediff":{"file":"/Users/rselbach/devel/lru/expirable.go","before":"// Package lru provides a generic, thread-safe LRU cache implementation.\npackage lru\n\nimport (\n\t\"container/list\"\n\t\"errors\"\n\t\"sync\"\n\t\"time\"\n)\n\n// expirableEntry extends cacheEntry with an expiry time.\ntype expirableEntry[K comparable, V any] struct {\n\tkey    K\n\tval    V\n\texpiry time.Time\n}\n\n// Expirable represents a thread-safe, fixed-size LRU cache with expiry functionality.\ntype Expirable[K comparable, V any] struct {\n\tcapacity int\n\titems    map[K]*list.Element\n\tlruList  *list.List\n\tmu       sync.RWMutex\n\tttl      time.Duration\n\ttimeNow  func() time.Time  // for testing\n\tonEvict  OnEvictFunc[K, V] // callback for evictions\n}\n\n// NewExpirable creates a new LRU cache with the given capacity and TTL.\n// Items will be automatically removed from the cache when they expire.\n// The capacity must be greater than zero, and the TTL must be greater than zero.\nfunc NewExpirable[K comparable, V any](capacity int, ttl time.Duration) (*Expirable[K, V], error) {\n\tif capacity <= 0 {\n\t\treturn nil, errors.New(\"capacity must be greater than zero\")\n\t}\n\tif ttl <= 0 {\n\t\treturn nil, errors.New(\"TTL must be greater than zero\")\n\t}\n\n\treturn &Expirable[K, V]{\n\t\tcapacity: capacity,\n\t\titems:    make(map[K]*list.Element),\n\t\tlruList:  list.New(),\n\t\tttl:      ttl,\n\t\ttimeNow:  time.Now,\n\t}, nil\n}\n\n// MustNewExpirable creates a new LRU cache with the given capacity and TTL.\n// It panics if the capacity or TTL is less than or equal to zero.\nfunc MustNewExpirable[K comparable, V any](capacity int, ttl time.Duration) *Expirable[K, V] {\n\tcache, err := NewExpirable[K, V](capacity, ttl)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn cache\n}\n\n// Get retrieves a value from the cache by key.\n// It returns the value and a boolean indicating whether the key was found and not expired.\n// This method also updates the item's position in the LRU list.\n// Expired items are removed when accessed.\nfunc (c *Expirable[K, V]) Get(key K) (V, bool) {\n\tc.mu.Lock()\n\n\tvar zero V\n\n\telement, found := c.items[key]\n\tif !found {\n\t\tc.mu.Unlock()\n\t\treturn zero, false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\n\t// check if the entry has expired\n\tif c.timeNow().After(entry.expiry) {\n\t\tevictedKey := entry.key\n\t\tevictedVal := entry.val\n\t\tonEvict := c.onEvict\n\t\tdelete(c.items, entry.key)\n\t\tc.lruList.Remove(element)\n\t\tc.mu.Unlock()\n\n\t\tif onEvict != nil {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t\treturn zero, false\n\t}\n\n\t// move to front of list to mark as recently used\n\tc.lruList.MoveToFront(element)\n\tval := entry.val\n\tc.mu.Unlock()\n\n\treturn val, true\n}\n\n// GetWithTTL retrieves a value and its remaining TTL from the cache by key.\n// It returns the value, remaining TTL, and a boolean indicating whether the key was found and not expired.\n// Expired items are removed when accessed.\nfunc (c *Expirable[K, V]) GetWithTTL(key K) (V, time.Duration, bool) {\n\tc.mu.Lock()\n\n\tvar zero V\n\n\telement, found := c.items[key]\n\tif !found {\n\t\tc.mu.Unlock()\n\t\treturn zero, 0, false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\n\tnow := c.timeNow()\n\t// check if the entry has expired\n\tif now.After(entry.expiry) {\n\t\tevictedKey := entry.key\n\t\tevictedVal := entry.val\n\t\tonEvict := c.onEvict\n\t\tdelete(c.items, entry.key)\n\t\tc.lruList.Remove(element)\n\t\tc.mu.Unlock()\n\n\t\tif onEvict != nil {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t\treturn zero, 0, false\n\t}\n\n\t// move to front of list to mark as recently used\n\tc.lruList.MoveToFront(element)\n\n\t// calculate remaining TTL\n\tttl := entry.expiry.Sub(now)\n\tif ttl < 0 {\n\t\tttl = 0\n\t}\n\tval := entry.val\n\tc.mu.Unlock()\n\n\treturn val, ttl, true\n}\n\n// GetOrSet retrieves a value from the cache by key, or computes and sets it if not present or expired.\n// The compute function is only called if the key is not present in the cache or is expired.\n// Note: if multiple goroutines call GetOrSet concurrently for the same missing/expired key,\n// compute may be called multiple times but only one result will be cached.\nfunc (c *Expirable[K, V]) GetOrSet(key K, compute func() (V, error)) (V, error) {\n\t// first try to get the item without a write lock\n\tif val, found := c.Get(key); found {\n\t\treturn val, nil\n\t}\n\n\t// compute the value outside the lock to avoid deadlock if compute\n\t// calls back into the cache\n\tval, err := compute()\n\tif err != nil {\n\t\tvar zero V\n\t\treturn zero, err\n\t}\n\n\tc.mu.Lock()\n\t// check again in case it was added while we were computing\n\telement, found := c.items[key]\n\tvar expiredEntry *expirableEntry[K, V]\n\tif found {\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif !c.timeNow().After(entry.expiry) {\n\t\t\tc.lruList.MoveToFront(element)\n\t\t\tval := entry.val\n\t\t\tc.mu.Unlock()\n\t\t\treturn val, nil\n\t\t}\n\t\t// expired entry, remove it and save for callback\n\t\texpiredEntry = entry\n\t\tdelete(c.items, key)\n\t\tc.lruList.Remove(element)\n\t}\n\n\t// add to cache\n\tevictedKey, evictedVal, hasEvicted := c.setLocked(key, val)\n\tonEvict := c.onEvict\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tif expiredEntry != nil {\n\t\t\tonEvict(expiredEntry.key, expiredEntry.val)\n\t\t}\n\t\tif hasEvicted {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t}\n\treturn val, nil\n}\n\n// Set adds or updates an item in the cache.\n// If the key already exists, its value is updated.\n// If the cache is at capacity, the least recently used item is evicted.\n// Any expired items are automatically removed when adding a new item.\nfunc (c *Expirable[K, V]) Set(key K, value V) {\n\tc.mu.Lock()\n\texpired := c.removeExpiredLocked()\n\tevictedKey, evictedVal, hasEvicted := c.setLocked(key, value)\n\tonEvict := c.onEvict\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tfor _, entry := range expired {\n\t\t\tonEvict(entry.key, entry.val)\n\t\t}\n\t\tif hasEvicted {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t}\n}\n\n// setLocked is an internal method that adds or updates an item in the cache.\n// it assumes the mutex is already locked and expired items have been removed.\n// Returns the evicted key/value and whether an eviction occurred.\nfunc (c *Expirable[K, V]) setLocked(key K, value V) (evictedKey K, evictedVal V, evicted bool) {\n\t// if key exists, update value and expiry and move to front\n\tif element, found := c.items[key]; found {\n\t\tc.lruList.MoveToFront(element)\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tentry.val = value\n\t\tentry.expiry = c.timeNow().Add(c.ttl)\n\t\treturn\n\t}\n\n\t// if we're at capacity, remove the least recently used item\n\tif c.lruList.Len() >= c.capacity {\n\t\toldest := c.lruList.Back()\n\t\tif oldest != nil {\n\t\t\tentry := oldest.Value.(*expirableEntry[K, V])\n\t\t\tevictedKey = entry.key\n\t\t\tevictedVal = entry.val\n\t\t\tevicted = true\n\t\t\tdelete(c.items, entry.key)\n\t\t\tc.lruList.Remove(oldest)\n\t\t}\n\t}\n\n\t// add new item\n\tentry := &expirableEntry[K, V]{\n\t\tkey:    key,\n\t\tval:    value,\n\t\texpiry: c.timeNow().Add(c.ttl),\n\t}\n\telement := c.lruList.PushFront(entry)\n\tc.items[key] = element\n\treturn\n}\n\n// Remove deletes an item from the cache by key.\n// It returns whether the key was found and removed.\nfunc (c *Expirable[K, V]) Remove(key K) bool {\n\tc.mu.Lock()\n\texpired := c.removeExpiredLocked()\n\n\telement, found := c.items[key]\n\tif !found {\n\t\tonEvict := c.onEvict\n\t\tc.mu.Unlock()\n\t\tif onEvict != nil {\n\t\t\tfor _, entry := range expired {\n\t\t\t\tonEvict(entry.key, entry.val)\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\tevictedKey := entry.key\n\tevictedVal := entry.val\n\tonEvict := c.onEvict\n\n\tdelete(c.items, key)\n\tc.lruList.Remove(element)\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tfor _, e := range expired {\n\t\t\tonEvict(e.key, e.val)\n\t\t}\n\t\tonEvict(evictedKey, evictedVal)\n\t}\n\treturn true\n}\n\n// Len returns the current number of non-expired items in the cache.\nfunc (c *Expirable[K, V]) Len() int {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\t// we'll need to count non-expired entries\n\tcount := 0\n\tnow := c.timeNow()\n\n\tfor _, element := range c.items {\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif !now.After(entry.expiry) {\n\t\t\tcount++\n\t\t}\n\t}\n\n\treturn count\n}\n\n// Clear removes all items from the cache.\nfunc (c *Expirable[K, V]) Clear() {\n\tc.mu.Lock()\n\tonEvict := c.onEvict\n\n\tvar evicted []expirableEntry[K, V]\n\tif onEvict != nil {\n\t\tnow := c.timeNow()\n\t\tevicted = make([]expirableEntry[K, V], 0, c.lruList.Len())\n\t\tfor element := c.lruList.Front(); element != nil; element = element.Next() {\n\t\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\t\tif !now.After(entry.expiry) {\n\t\t\t\tevicted = append(evicted, *entry)\n\t\t\t}\n\t\t}\n\t}\n\n\tc.items = make(map[K]*list.Element)\n\tc.lruList = list.New()\n\tc.mu.Unlock()\n\n\tfor _, entry := range evicted {\n\t\tonEvict(entry.key, entry.val)\n\t}\n}\n\n// Contains checks if a key exists in the cache and is not expired.\nfunc (c *Expirable[K, V]) Contains(key K) bool {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\telement, found := c.items[key]\n\tif !found {\n\t\treturn false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\treturn !c.timeNow().After(entry.expiry)\n}\n\n// Keys returns a slice of all keys in the cache that haven't expired.\n// The order is from most recently used to least recently used.\nfunc (c *Expirable[K, V]) Keys() []K {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tnow := c.timeNow()\n\tkeys := make([]K, 0, len(c.items))\n\n\tfor element := c.lruList.Front(); element != nil; element = element.Next() {\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif !now.After(entry.expiry) {\n\t\t\tkeys = append(keys, entry.key)\n\t\t}\n\t}\n\n\treturn keys\n}\n\n// Capacity returns the maximum capacity of the cache.\nfunc (c *Expirable[K, V]) Capacity() int {\n\treturn c.capacity\n}\n\n// TTL returns the time-to-live duration for cache entries.\nfunc (c *Expirable[K, V]) TTL() time.Duration {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\treturn c.ttl\n}\n\n// SetTTL updates the TTL for future cache entries.\n// It does not affect existing entries.\nfunc (c *Expirable[K, V]) SetTTL(ttl time.Duration) error {\n\tif ttl <= 0 {\n\t\treturn errors.New(\"TTL must be greater than zero\")\n\t}\n\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tc.ttl = ttl\n\treturn nil\n}\n\n// OnEvict sets a callback function that will be called when an entry is evicted from the cache.\n// The callback will receive the key and value of the evicted entry.\n// This includes both manual removals and automatic evictions due to capacity or expiry.\nfunc (c *Expirable[K, V]) OnEvict(f OnEvictFunc[K, V]) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tc.onEvict = f\n}\n\n// SetTimeNowFunc replaces the function used to get the current time.\n// This is primarily useful for testing. Passing nil resets to time.Now.\nfunc (c *Expirable[K, V]) SetTimeNowFunc(f func() time.Time) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif f == nil {\n\t\tf = time.Now\n\t}\n\tc.timeNow = f\n}\n\n// removeExpiredLocked removes all expired items from the cache.\n// it assumes the mutex is already locked.\n// Returns a slice of expired entries for callback invocation outside the lock.\nfunc (c *Expirable[K, V]) removeExpiredLocked() []expirableEntry[K, V] {\n\tnow := c.timeNow()\n\tvar expired []expirableEntry[K, V]\n\n\tfor element := c.lruList.Front(); element != nil; {\n\t\tnextElement := element.Next()\n\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif now.After(entry.expiry) {\n\t\t\texpired = append(expired, *entry)\n\t\t\tdelete(c.items, entry.key)\n\t\t\tc.lruList.Remove(element)\n\t\t}\n\n\t\telement = nextElement\n\t}\n\treturn expired\n}\n\n// RemoveExpired explicitly removes all expired items from the cache.\n// Returns the number of items removed.\n// This method will call the eviction callback for each expired item if one is set.\nfunc (c *Expirable[K, V]) RemoveExpired() int {\n\tc.mu.Lock()\n\n\tnow := c.timeNow()\n\tremoved := 0\n\n\texpiredItems := make([]K, 0)\n\texpiredValues := make([]V, 0)\n\n\tfor element := c.lruList.Front(); element != nil; {\n\t\tnextElement := element.Next()\n\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif now.After(entry.expiry) {\n\t\t\texpiredItems = append(expiredItems, entry.key)\n\t\t\texpiredValues = append(expiredValues, entry.val)\n\t\t\tdelete(c.items, entry.key)\n\t\t\tc.lruList.Remove(element)\n\t\t\tremoved++\n\t\t}\n\n\t\telement = nextElement\n\t}\n\n\tonEvict := c.onEvict\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tfor i := range expiredItems {\n\t\t\tonEvict(expiredItems[i], expiredValues[i])\n\t\t}\n\t}\n\n\treturn removed\n}\n","after":"package lru\n\nimport (\n\t\"container/list\"\n\t\"errors\"\n\t\"sync\"\n\t\"time\"\n)\n\n// expirableEntry extends cacheEntry with an expiry time.\ntype expirableEntry[K comparable, V any] struct {\n\tkey    K\n\tval    V\n\texpiry time.Time\n}\n\n// Expirable represents a thread-safe, fixed-size LRU cache with expiry functionality.\ntype Expirable[K comparable, V any] struct {\n\tcapacity int\n\titems    map[K]*list.Element\n\tlruList  *list.List\n\tmu       sync.RWMutex\n\tttl      time.Duration\n\ttimeNow  func() time.Time  // for testing\n\tonEvict  OnEvictFunc[K, V] // callback for evictions\n}\n\n// NewExpirable creates a new LRU cache with the given capacity and TTL.\n// Items will be automatically removed from the cache when they expire.\n// The capacity must be greater than zero, and the TTL must be greater than zero.\nfunc NewExpirable[K comparable, V any](capacity int, ttl time.Duration) (*Expirable[K, V], error) {\n\tif capacity <= 0 {\n\t\treturn nil, errors.New(\"capacity must be greater than zero\")\n\t}\n\tif ttl <= 0 {\n\t\treturn nil, errors.New(\"TTL must be greater than zero\")\n\t}\n\n\treturn &Expirable[K, V]{\n\t\tcapacity: capacity,\n\t\titems:    make(map[K]*list.Element),\n\t\tlruList:  list.New(),\n\t\tttl:      ttl,\n\t\ttimeNow:  time.Now,\n\t}, nil\n}\n\n// MustNewExpirable creates a new LRU cache with the given capacity and TTL.\n// It panics if the capacity or TTL is less than or equal to zero.\nfunc MustNewExpirable[K comparable, V any](capacity int, ttl time.Duration) *Expirable[K, V] {\n\tcache, err := NewExpirable[K, V](capacity, ttl)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn cache\n}\n\n// Get retrieves a value from the cache by key.\n// It returns the value and a boolean indicating whether the key was found and not expired.\n// This method also updates the item's position in the LRU list.\n// Expired items are removed when accessed.\nfunc (c *Expirable[K, V]) Get(key K) (V, bool) {\n\tc.mu.Lock()\n\n\tvar zero V\n\n\telement, found := c.items[key]\n\tif !found {\n\t\tc.mu.Unlock()\n\t\treturn zero, false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\n\t// check if the entry has expired\n\tif c.timeNow().After(entry.expiry) {\n\t\tevictedKey := entry.key\n\t\tevictedVal := entry.val\n\t\tonEvict := c.onEvict\n\t\tdelete(c.items, entry.key)\n\t\tc.lruList.Remove(element)\n\t\tc.mu.Unlock()\n\n\t\tif onEvict != nil {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t\treturn zero, false\n\t}\n\n\t// move to front of list to mark as recently used\n\tc.lruList.MoveToFront(element)\n\tval := entry.val\n\tc.mu.Unlock()\n\n\treturn val, true\n}\n\n// GetWithTTL retrieves a value and its remaining TTL from the cache by key.\n// It returns the value, remaining TTL, and a boolean indicating whether the key was found and not expired.\n// Expired items are removed when accessed.\nfunc (c *Expirable[K, V]) GetWithTTL(key K) (V, time.Duration, bool) {\n\tc.mu.Lock()\n\n\tvar zero V\n\n\telement, found := c.items[key]\n\tif !found {\n\t\tc.mu.Unlock()\n\t\treturn zero, 0, false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\n\tnow := c.timeNow()\n\t// check if the entry has expired\n\tif now.After(entry.expiry) {\n\t\tevictedKey := entry.key\n\t\tevictedVal := entry.val\n\t\tonEvict := c.onEvict\n\t\tdelete(c.items, entry.key)\n\t\tc.lruList.Remove(element)\n\t\tc.mu.Unlock()\n\n\t\tif onEvict != nil {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t\treturn zero, 0, false\n\t}\n\n\t// move to front of list to mark as recently used\n\tc.lruList.MoveToFront(element)\n\n\t// calculate remaining TTL\n\tttl := entry.expiry.Sub(now)\n\tif ttl < 0 {\n\t\tttl = 0\n\t}\n\tval := entry.val\n\tc.mu.Unlock()\n\n\treturn val, ttl, true\n}\n\n// GetOrSet retrieves a value from the cache by key, or computes and sets it if not present or expired.\n// The compute function is only called if the key is not present in the cache or is expired.\n// Note: if multiple goroutines call GetOrSet concurrently for the same missing/expired key,\n// compute may be called multiple times but only one result will be cached.\nfunc (c *Expirable[K, V]) GetOrSet(key K, compute func() (V, error)) (V, error) {\n\t// first try to get the item without a write lock\n\tif val, found := c.Get(key); found {\n\t\treturn val, nil\n\t}\n\n\t// compute the value outside the lock to avoid deadlock if compute\n\t// calls back into the cache\n\tval, err := compute()\n\tif err != nil {\n\t\tvar zero V\n\t\treturn zero, err\n\t}\n\n\tc.mu.Lock()\n\t// check again in case it was added while we were computing\n\telement, found := c.items[key]\n\tvar expiredEntry *expirableEntry[K, V]\n\tif found {\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif !c.timeNow().After(entry.expiry) {\n\t\t\tc.lruList.MoveToFront(element)\n\t\t\tval := entry.val\n\t\t\tc.mu.Unlock()\n\t\t\treturn val, nil\n\t\t}\n\t\t// expired entry, remove it and save for callback\n\t\texpiredEntry = entry\n\t\tdelete(c.items, key)\n\t\tc.lruList.Remove(element)\n\t}\n\n\t// add to cache\n\tevictedKey, evictedVal, hasEvicted := c.setLocked(key, val)\n\tonEvict := c.onEvict\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tif expiredEntry != nil {\n\t\t\tonEvict(expiredEntry.key, expiredEntry.val)\n\t\t}\n\t\tif hasEvicted {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t}\n\treturn val, nil\n}\n\n// Set adds or updates an item in the cache.\n// If the key already exists, its value is updated.\n// If the cache is at capacity, the least recently used item is evicted.\n// Any expired items are automatically removed when adding a new item.\nfunc (c *Expirable[K, V]) Set(key K, value V) {\n\tc.mu.Lock()\n\texpired := c.removeExpiredLocked()\n\tevictedKey, evictedVal, hasEvicted := c.setLocked(key, value)\n\tonEvict := c.onEvict\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tfor _, entry := range expired {\n\t\t\tonEvict(entry.key, entry.val)\n\t\t}\n\t\tif hasEvicted {\n\t\t\tonEvict(evictedKey, evictedVal)\n\t\t}\n\t}\n}\n\n// setLocked is an internal method that adds or updates an item in the cache.\n// it assumes the mutex is already locked and expired items have been removed.\n// Returns the evicted key/value and whether an eviction occurred.\nfunc (c *Expirable[K, V]) setLocked(key K, value V) (evictedKey K, evictedVal V, evicted bool) {\n\t// if key exists, update value and expiry and move to front\n\tif element, found := c.items[key]; found {\n\t\tc.lruList.MoveToFront(element)\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tentry.val = value\n\t\tentry.expiry = c.timeNow().Add(c.ttl)\n\t\treturn\n\t}\n\n\t// if we're at capacity, remove the least recently used item\n\tif c.lruList.Len() >= c.capacity {\n\t\toldest := c.lruList.Back()\n\t\tif oldest != nil {\n\t\t\tentry := oldest.Value.(*expirableEntry[K, V])\n\t\t\tevictedKey = entry.key\n\t\t\tevictedVal = entry.val\n\t\t\tevicted = true\n\t\t\tdelete(c.items, entry.key)\n\t\t\tc.lruList.Remove(oldest)\n\t\t}\n\t}\n\n\t// add new item\n\tentry := &expirableEntry[K, V]{\n\t\tkey:    key,\n\t\tval:    value,\n\t\texpiry: c.timeNow().Add(c.ttl),\n\t}\n\telement := c.lruList.PushFront(entry)\n\tc.items[key] = element\n\treturn\n}\n\n// Remove deletes an item from the cache by key.\n// It returns whether the key was found and removed.\nfunc (c *Expirable[K, V]) Remove(key K) bool {\n\tc.mu.Lock()\n\texpired := c.removeExpiredLocked()\n\n\telement, found := c.items[key]\n\tif !found {\n\t\tonEvict := c.onEvict\n\t\tc.mu.Unlock()\n\t\tif onEvict != nil {\n\t\t\tfor _, entry := range expired {\n\t\t\t\tonEvict(entry.key, entry.val)\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\tevictedKey := entry.key\n\tevictedVal := entry.val\n\tonEvict := c.onEvict\n\n\tdelete(c.items, key)\n\tc.lruList.Remove(element)\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tfor _, e := range expired {\n\t\t\tonEvict(e.key, e.val)\n\t\t}\n\t\tonEvict(evictedKey, evictedVal)\n\t}\n\treturn true\n}\n\n// Len returns the current number of non-expired items in the cache.\nfunc (c *Expirable[K, V]) Len() int {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\t// we'll need to count non-expired entries\n\tcount := 0\n\tnow := c.timeNow()\n\n\tfor _, element := range c.items {\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif !now.After(entry.expiry) {\n\t\t\tcount++\n\t\t}\n\t}\n\n\treturn count\n}\n\n// Clear removes all items from the cache.\nfunc (c *Expirable[K, V]) Clear() {\n\tc.mu.Lock()\n\tonEvict := c.onEvict\n\n\tvar evicted []expirableEntry[K, V]\n\tif onEvict != nil {\n\t\tnow := c.timeNow()\n\t\tevicted = make([]expirableEntry[K, V], 0, c.lruList.Len())\n\t\tfor element := c.lruList.Front(); element != nil; element = element.Next() {\n\t\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\t\tif !now.After(entry.expiry) {\n\t\t\t\tevicted = append(evicted, *entry)\n\t\t\t}\n\t\t}\n\t}\n\n\tc.items = make(map[K]*list.Element)\n\tc.lruList = list.New()\n\tc.mu.Unlock()\n\n\tfor _, entry := range evicted {\n\t\tonEvict(entry.key, entry.val)\n\t}\n}\n\n// Contains checks if a key exists in the cache and is not expired.\nfunc (c *Expirable[K, V]) Contains(key K) bool {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\telement, found := c.items[key]\n\tif !found {\n\t\treturn false\n\t}\n\n\tentry := element.Value.(*expirableEntry[K, V])\n\treturn !c.timeNow().After(entry.expiry)\n}\n\n// Keys returns a slice of all keys in the cache that haven't expired.\n// The order is from most recently used to least recently used.\nfunc (c *Expirable[K, V]) Keys() []K {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tnow := c.timeNow()\n\tkeys := make([]K, 0, len(c.items))\n\n\tfor element := c.lruList.Front(); element != nil; element = element.Next() {\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif !now.After(entry.expiry) {\n\t\t\tkeys = append(keys, entry.key)\n\t\t}\n\t}\n\n\treturn keys\n}\n\n// Capacity returns the maximum capacity of the cache.\nfunc (c *Expirable[K, V]) Capacity() int {\n\treturn c.capacity\n}\n\n// TTL returns the time-to-live duration for cache entries.\nfunc (c *Expirable[K, V]) TTL() time.Duration {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\treturn c.ttl\n}\n\n// SetTTL updates the TTL for future cache entries.\n// It does not affect existing entries.\nfunc (c *Expirable[K, V]) SetTTL(ttl time.Duration) error {\n\tif ttl <= 0 {\n\t\treturn errors.New(\"TTL must be greater than zero\")\n\t}\n\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tc.ttl = ttl\n\treturn nil\n}\n\n// OnEvict sets a callback function that will be called when an entry is evicted from the cache.\n// The callback will receive the key and value of the evicted entry.\n// This includes both manual removals and automatic evictions due to capacity or expiry.\nfunc (c *Expirable[K, V]) OnEvict(f OnEvictFunc[K, V]) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tc.onEvict = f\n}\n\n// SetTimeNowFunc replaces the function used to get the current time.\n// This is primarily useful for testing. Passing nil resets to time.Now.\nfunc (c *Expirable[K, V]) SetTimeNowFunc(f func() time.Time) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif f == nil {\n\t\tf = time.Now\n\t}\n\tc.timeNow = f\n}\n\n// removeExpiredLocked removes all expired items from the cache.\n// it assumes the mutex is already locked.\n// Returns a slice of expired entries for callback invocation outside the lock.\nfunc (c *Expirable[K, V]) removeExpiredLocked() []expirableEntry[K, V] {\n\tnow := c.timeNow()\n\tvar expired []expirableEntry[K, V]\n\n\tfor element := c.lruList.Front(); element != nil; {\n\t\tnextElement := element.Next()\n\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif now.After(entry.expiry) {\n\t\t\texpired = append(expired, *entry)\n\t\t\tdelete(c.items, entry.key)\n\t\t\tc.lruList.Remove(element)\n\t\t}\n\n\t\telement = nextElement\n\t}\n\treturn expired\n}\n\n// RemoveExpired explicitly removes all expired items from the cache.\n// Returns the number of items removed.\n// This method will call the eviction callback for each expired item if one is set.\nfunc (c *Expirable[K, V]) RemoveExpired() int {\n\tc.mu.Lock()\n\n\tnow := c.timeNow()\n\tremoved := 0\n\n\texpiredItems := make([]K, 0)\n\texpiredValues := make([]V, 0)\n\n\tfor element := c.lruList.Front(); element != nil; {\n\t\tnextElement := element.Next()\n\n\t\tentry := element.Value.(*expirableEntry[K, V])\n\t\tif now.After(entry.expiry) {\n\t\t\texpiredItems = append(expiredItems, entry.key)\n\t\t\texpiredValues = append(expiredValues, entry.val)\n\t\t\tdelete(c.items, entry.key)\n\t\t\tc.lruList.Remove(element)\n\t\t\tremoved++\n\t\t}\n\n\t\telement = nextElement\n\t}\n\n\tonEvict := c.onEvict\n\tc.mu.Unlock()\n\n\tif onEvict != nil {\n\t\tfor i := range expiredItems {\n\t\t\tonEvict(expiredItems[i], expiredValues[i])\n\t\t}\n\t}\n\n\treturn removed\n}\n","additions":0,"deletions":1}}}
{"type":"tool_use","timestamp":"2025-12-29T19:46:21.644Z","tool_name":"write","tool_input":{"filePath":"/Users/rselbach/devel/lru/README.md","content":"# Generic LRU Cache for Go\n\n[![Go Reference](https://pkg.go.dev/badge/github.com/rselbach/lru.svg)](https://pkg.go.dev/github.com/rselbach/lru)\n\nA thread-safe, generic LRU cache implementation in Go with optional TTL expiration and eviction callbacks.\n\n## Features\n\n- Generic implementation (Go 1.18+)\n- O(1) lookups, insertions, and deletions\n- Thread-safe for concurrent access\n- Optional time-based expiration ([Expirable])\n- Eviction callbacks\n\n## Installation\n\n```shell\ngo get github.com/rselbach/lru\n```\n\n## Quick Start\n\n```go\ncache := lru.MustNew[string, int](100)\ncache.Set(\"key\", 42)\nvalue, found := cache.Get(\"key\")\n```\n\nWith TTL expiration:\n\n```go\ncache := lru.MustNewExpirable[string, int](100, 5*time.Minute)\ncache.Set(\"key\", 42)\nvalue, ttl, found := cache.GetWithTTL(\"key\")\n```\n\nSee the [package documentation](https://pkg.go.dev/github.com/rselbach/lru) for complete API reference and examples.\n\n## License\n\n[MIT License](LICENSE)\n"}}
{"type":"tool_result","timestamp":"2025-12-29T19:46:21.646Z","tool_name":"write","tool_input":{"filePath":"/Users/rselbach/devel/lru/README.md","content":"# Generic LRU Cache for Go\n\n[![Go Reference](https://pkg.go.dev/badge/github.com/rselbach/lru.svg)](https://pkg.go.dev/github.com/rselbach/lru)\n\nA thread-safe, generic LRU cache implementation in Go with optional TTL expiration and eviction callbacks.\n\n## Features\n\n- Generic implementation (Go 1.18+)\n- O(1) lookups, insertions, and deletions\n- Thread-safe for concurrent access\n- Optional time-based expiration ([Expirable])\n- Eviction callbacks\n\n## Installation\n\n```shell\ngo get github.com/rselbach/lru\n```\n\n## Quick Start\n\n```go\ncache := lru.MustNew[string, int](100)\ncache.Set(\"key\", 42)\nvalue, found := cache.Get(\"key\")\n```\n\nWith TTL expiration:\n\n```go\ncache := lru.MustNewExpirable[string, int](100, 5*time.Minute)\ncache.Set(\"key\", 42)\nvalue, ttl, found := cache.GetWithTTL(\"key\")\n```\n\nSee the [package documentation](https://pkg.go.dev/github.com/rselbach/lru) for complete API reference and examples.\n\n## License\n\n[MIT License](LICENSE)\n"},"tool_output":{"diagnostics":{"/Users/rselbach/devel/lru/lru.go":[],"/Users/rselbach/devel/lru/expirable.go":[],"/Users/rselbach/devel/lru/lru_test.go":[],"/Users/rselbach/devel/lru/expirable_test.go":[],"/Users/rselbach/devel/lru/callbacks_test.go":[],"/Users/rselbach/devel/lru/expirable_example_test.go":[],"/Users/rselbach/devel/lru/example_test.go":[],"/Users/rselbach/devel/lru/doc.go":[]},"filepath":"/Users/rselbach/devel/lru/README.md","exists":true}}
{"type":"tool_use","timestamp":"2025-12-29T19:46:31.479Z","tool_name":"bash","tool_input":{"command":"cd /Users/rselbach/devel/lru && go test -race ./... && echo \"---\" && go doc","description":"Verify tests pass and godoc is clean","env":"{\"CI\": \"true\", \"DEBIAN_FRONTEND\": \"noninteractive\", \"GIT_TERMINAL_PROMPT\": \"0\", \"GCM_INTERACTIVE\": \"never\", \"HOMEBREW_NO_AUTO_UPDATE\": \"1\", \"GIT_EDITOR\": \"true\", \"EDITOR\": \"true\", \"VISUAL\": \"true\", \"GIT_SEQUENCE_EDITOR\": \"true\", \"GIT_PAGER\": \"cat\", \"PAGER\": \"cat\", \"npm_config_yes\": \"true\", \"PIP_NO_INPUT\": \"1\", \"YARN_ENABLE_IMMUTABLE_INSTALLS\": \"false\"}"}}
{"type":"tool_result","timestamp":"2025-12-29T19:46:34.258Z","tool_name":"bash","tool_input":{"command":"cd /Users/rselbach/devel/lru && go test -race ./... && echo \"---\" && go doc","description":"Verify tests pass and godoc is clean","env":{"0":"{","1":"\"","2":"C","3":"I","4":"\"","5":":","6":" ","7":"\"","8":"t","9":"r","10":"u","11":"e","12":"\"","13":",","14":" ","15":"\"","16":"D","17":"E","18":"B","19":"I","20":"A","21":"N","22":"_","23":"F","24":"R","25":"O","26":"N","27":"T","28":"E","29":"N","30":"D","31":"\"","32":":","33":" ","34":"\"","35":"n","36":"o","37":"n","38":"i","39":"n","40":"t","41":"e","42":"r","43":"a","44":"c","45":"t","46":"i","47":"v","48":"e","49":"\"","50":",","51":" ","52":"\"","53":"G","54":"I","55":"T","56":"_","57":"T","58":"E","59":"R","60":"M","61":"I","62":"N","63":"A","64":"L","65":"_","66":"P","67":"R","68":"O","69":"M","70":"P","71":"T","72":"\"","73":":","74":" ","75":"\"","76":"0","77":"\"","78":",","79":" ","80":"\"","81":"G","82":"C","83":"M","84":"_","85":"I","86":"N","87":"T","88":"E","89":"R","90":"A","91":"C","92":"T","93":"I","94":"V","95":"E","96":"\"","97":":","98":" ","99":"\"","100":"n","101":"e","102":"v","103":"e","104":"r","105":"\"","106":",","107":" ","108":"\"","109":"H","110":"O","111":"M","112":"E","113":"B","114":"R","115":"E","116":"W","117":"_","118":"N","119":"O","120":"_","121":"A","122":"U","123":"T","124":"O","125":"_","126":"U","127":"P","128":"D","129":"A","130":"T","131":"E","132":"\"","133":":","134":" ","135":"\"","136":"1","137":"\"","138":",","139":" ","140":"\"","141":"G","142":"I","143":"T","144":"_","145":"E","146":"D","147":"I","148":"T","149":"O","150":"R","151":"\"","152":":","153":" ","154":"\"","155":"t","156":"r","157":"u","158":"e","159":"\"","160":",","161":" ","162":"\"","163":"E","164":"D","165":"I","166":"T","167":"O","168":"R","169":"\"","170":":","171":" ","172":"\"","173":"t","174":"r","175":"u","176":"e","177":"\"","178":",","179":" ","180":"\"","181":"V","182":"I","183":"S","184":"U","185":"A","186":"L","187":"\"","188":":","189":" ","190":"\"","191":"t","192":"r","193":"u","194":"e","195":"\"","196":",","197":" ","198":"\"","199":"G","200":"I","201":"T","202":"_","203":"S","204":"E","205":"Q","206":"U","207":"E","208":"N","209":"C","210":"E","211":"_","212":"E","213":"D","214":"I","215":"T","216":"O","217":"R","218":"\"","219":":","220":" ","221":"\"","222":"t","223":"r","224":"u","225":"e","226":"\"","227":",","228":" ","229":"\"","230":"G","231":"I","232":"T","233":"_","234":"P","235":"A","236":"G","237":"E","238":"R","239":"\"","240":":","241":" ","242":"\"","243":"c","244":"a","245":"t","246":"\"","247":",","248":" ","249":"\"","250":"P","251":"A","252":"G","253":"E","254":"R","255":"\"","256":":","257":" ","258":"\"","259":"c","260":"a","261":"t","262":"\"","263":",","264":" ","265":"\"","266":"n","267":"p","268":"m","269":"_","270":"c","271":"o","272":"n","273":"f","274":"i","275":"g","276":"_","277":"y","278":"e","279":"s","280":"\"","281":":","282":" ","283":"\"","284":"t","285":"r","286":"u","287":"e","288":"\"","289":",","290":" ","291":"\"","292":"P","293":"I","294":"P","295":"_","296":"N","297":"O","298":"_","299":"I","300":"N","301":"P","302":"U","303":"T","304":"\"","305":":","306":" ","307":"\"","308":"1","309":"\"","310":",","311":" ","312":"\"","313":"Y","314":"A","315":"R","316":"N","317":"_","318":"E","319":"N","320":"A","321":"B","322":"L","323":"E","324":"_","325":"I","326":"M","327":"M","328":"U","329":"T","330":"A","331":"B","332":"L","333":"E","334":"_","335":"I","336":"N","337":"S","338":"T","339":"A","340":"L","341":"L","342":"S","343":"\"","344":":","345":" ","346":"\"","347":"f","348":"a","349":"l","350":"s","351":"e","352":"\"","353":"}","CI":"true","DEBIAN_FRONTEND":"noninteractive","GIT_TERMINAL_PROMPT":"0","GCM_INTERACTIVE":"never","HOMEBREW_NO_AUTO_UPDATE":"1","GIT_EDITOR":"true","EDITOR":"true","VISUAL":"true","GIT_SEQUENCE_EDITOR":"true","GIT_PAGER":"cat","PAGER":"cat","npm_config_yes":"true","PIP_NO_INPUT":"1","YARN_ENABLE_IMMUTABLE_INSTALLS":"false"}},"tool_output":{"output":"ok  \tgithub.com/rselbach/lru\t2.323s\n---\npackage lru // import \"github.com/rselbach/lru\"\n\nPackage lru provides generic, thread-safe LRU cache implementations.\n\nTwo cache types are provided:\n\n  - Cache: A standard LRU cache with fixed capacity\n  - Expirable: An LRU cache with per-entry TTL expiration\n\nBoth are safe for concurrent use and support eviction callbacks.\n\n# Basic Usage\n\nCreate a cache and store values:\n\n    cache := lru.MustNew[string, int](100)\n    cache.Set(\"key\", 42)\n    value, found := cache.Get(\"key\")\n\n# Memoization with GetOrSet\n\nCompute values on cache miss:\n\n    result, err := cache.GetOrSet(\"key\", func() (int, error) {\n        return expensiveComputation()\n    })\n\n# Expirable Cache\n\nCreate a cache where entries expire after a duration:\n\n    cache := lru.MustNewExpirable[string, int](100, 5*time.Minute)\n    cache.Set(\"key\", 42)\n    value, ttl, found := cache.GetWithTTL(\"key\")\n\nExpired entries are removed lazily on access or during write operations.\nCall Expirable.RemoveExpired to explicitly purge all expired entries.\n\n# Eviction Callbacks\n\nRegister a callback to be notified when entries are evicted:\n\n    cache.OnEvict(func(key string, value int) {\n        fmt.Printf(\"evicted: %s=%d\\n\", key, value)\n    })\n\nCallbacks are invoked for capacity evictions, explicit removals via\nCache.Remove, and Cache.Clear. For Expirable.Clear, callbacks are only invoked\nfor entries that have not yet expired.\n\nvar ErrKeyNotFound = errors.New(\"key not found in cache\") ...\ntype Cache[K comparable, V any] struct{ ... }\n    func MustNew[K comparable, V any](capacity int) *Cache[K, V]\n    func New[K comparable, V any](capacity int) (*Cache[K, V], error)\ntype Expirable[K comparable, V any] struct{ ... }\n    func MustNewExpirable[K comparable, V any](capacity int, ttl time.Duration) *Expirable[K, V]\n    func NewExpirable[K comparable, V any](capacity int, ttl time.Duration) (*Expirable[K, V], error)\ntype OnEvictFunc[K comparable, V any] func(key K, value V)\n","exit":0,"description":"Verify tests pass and godoc is clean"}}
{"type":"tool_use","timestamp":"2025-12-29T19:46:43.317Z","tool_name":"bash","tool_input":{"command":"cd /Users/rselbach/devel/lru && go doc -all 2>&1 | grep -A2 \"^func Example\"","description":"Check examples in godoc"}}
{"type":"tool_result","timestamp":"2025-12-29T19:46:43.374Z","tool_name":"bash","tool_input":{"command":"cd /Users/rselbach/devel/lru && go doc -all 2>&1 | grep -A2 \"^func Example\"","description":"Check examples in godoc","env":{"CI":"true","DEBIAN_FRONTEND":"noninteractive","GIT_TERMINAL_PROMPT":"0","GCM_INTERACTIVE":"never","HOMEBREW_NO_AUTO_UPDATE":"1","GIT_EDITOR":"true","EDITOR":"true","VISUAL":"true","GIT_SEQUENCE_EDITOR":"true","GIT_PAGER":"cat","PAGER":"cat","npm_config_yes":"true","PIP_NO_INPUT":"1","YARN_ENABLE_IMMUTABLE_INSTALLS":"false"}},"tool_output":{"output":"","exit":1,"description":"Check examples in godoc"}}
{"type":"tool_use","timestamp":"2025-12-29T19:46:53.940Z","tool_name":"bash","tool_input":{"command":"cd /Users/rselbach/devel/lru && go test -v -run Example 2>&1 | head -30","description":"Run example tests","env":"{\"CI\": \"true\", \"DEBIAN_FRONTEND\": \"noninteractive\", \"GIT_TERMINAL_PROMPT\": \"0\", \"GCM_INTERACTIVE\": \"never\", \"HOMEBREW_NO_AUTO_UPDATE\": \"1\", \"GIT_EDITOR\": \"true\", \"EDITOR\": \"true\", \"VISUAL\": \"true\", \"GIT_SEQUENCE_EDITOR\": \"true\", \"GIT_PAGER\": \"cat\", \"PAGER\": \"cat\", \"npm_config_yes\": \"true\", \"PIP_NO_INPUT\": \"1\", \"YARN_ENABLE_IMMUTABLE_INSTALLS\": \"false\"}"}}
{"type":"tool_result","timestamp":"2025-12-29T19:46:55.202Z","tool_name":"bash","tool_input":{"command":"cd /Users/rselbach/devel/lru && go test -v -run Example 2>&1 | head -30","description":"Run example tests","env":{"0":"{","1":"\"","2":"C","3":"I","4":"\"","5":":","6":" ","7":"\"","8":"t","9":"r","10":"u","11":"e","12":"\"","13":",","14":" ","15":"\"","16":"D","17":"E","18":"B","19":"I","20":"A","21":"N","22":"_","23":"F","24":"R","25":"O","26":"N","27":"T","28":"E","29":"N","30":"D","31":"\"","32":":","33":" ","34":"\"","35":"n","36":"o","37":"n","38":"i","39":"n","40":"t","41":"e","42":"r","43":"a","44":"c","45":"t","46":"i","47":"v","48":"e","49":"\"","50":",","51":" ","52":"\"","53":"G","54":"I","55":"T","56":"_","57":"T","58":"E","59":"R","60":"M","61":"I","62":"N","63":"A","64":"L","65":"_","66":"P","67":"R","68":"O","69":"M","70":"P","71":"T","72":"\"","73":":","74":" ","75":"\"","76":"0","77":"\"","78":",","79":" ","80":"\"","81":"G","82":"C","83":"M","84":"_","85":"I","86":"N","87":"T","88":"E","89":"R","90":"A","91":"C","92":"T","93":"I","94":"V","95":"E","96":"\"","97":":","98":" ","99":"\"","100":"n","101":"e","102":"v","103":"e","104":"r","105":"\"","106":",","107":" ","108":"\"","109":"H","110":"O","111":"M","112":"E","113":"B","114":"R","115":"E","116":"W","117":"_","118":"N","119":"O","120":"_","121":"A","122":"U","123":"T","124":"O","125":"_","126":"U","127":"P","128":"D","129":"A","130":"T","131":"E","132":"\"","133":":","134":" ","135":"\"","136":"1","137":"\"","138":",","139":" ","140":"\"","141":"G","142":"I","143":"T","144":"_","145":"E","146":"D","147":"I","148":"T","149":"O","150":"R","151":"\"","152":":","153":" ","154":"\"","155":"t","156":"r","157":"u","158":"e","159":"\"","160":",","161":" ","162":"\"","163":"E","164":"D","165":"I","166":"T","167":"O","168":"R","169":"\"","170":":","171":" ","172":"\"","173":"t","174":"r","175":"u","176":"e","177":"\"","178":",","179":" ","180":"\"","181":"V","182":"I","183":"S","184":"U","185":"A","186":"L","187":"\"","188":":","189":" ","190":"\"","191":"t","192":"r","193":"u","194":"e","195":"\"","196":",","197":" ","198":"\"","199":"G","200":"I","201":"T","202":"_","203":"S","204":"E","205":"Q","206":"U","207":"E","208":"N","209":"C","210":"E","211":"_","212":"E","213":"D","214":"I","215":"T","216":"O","217":"R","218":"\"","219":":","220":" ","221":"\"","222":"t","223":"r","224":"u","225":"e","226":"\"","227":",","228":" ","229":"\"","230":"G","231":"I","232":"T","233":"_","234":"P","235":"A","236":"G","237":"E","238":"R","239":"\"","240":":","241":" ","242":"\"","243":"c","244":"a","245":"t","246":"\"","247":",","248":" ","249":"\"","250":"P","251":"A","252":"G","253":"E","254":"R","255":"\"","256":":","257":" ","258":"\"","259":"c","260":"a","261":"t","262":"\"","263":",","264":" ","265":"\"","266":"n","267":"p","268":"m","269":"_","270":"c","271":"o","272":"n","273":"f","274":"i","275":"g","276":"_","277":"y","278":"e","279":"s","280":"\"","281":":","282":" ","283":"\"","284":"t","285":"r","286":"u","287":"e","288":"\"","289":",","290":" ","291":"\"","292":"P","293":"I","294":"P","295":"_","296":"N","297":"O","298":"_","299":"I","300":"N","301":"P","302":"U","303":"T","304":"\"","305":":","306":" ","307":"\"","308":"1","309":"\"","310":",","311":" ","312":"\"","313":"Y","314":"A","315":"R","316":"N","317":"_","318":"E","319":"N","320":"A","321":"B","322":"L","323":"E","324":"_","325":"I","326":"M","327":"M","328":"U","329":"T","330":"A","331":"B","332":"L","333":"E","334":"_","335":"I","336":"N","337":"S","338":"T","339":"A","340":"L","341":"L","342":"S","343":"\"","344":":","345":" ","346":"\"","347":"f","348":"a","349":"l","350":"s","351":"e","352":"\"","353":"}","CI":"true","DEBIAN_FRONTEND":"noninteractive","GIT_TERMINAL_PROMPT":"0","GCM_INTERACTIVE":"never","HOMEBREW_NO_AUTO_UPDATE":"1","GIT_EDITOR":"true","EDITOR":"true","VISUAL":"true","GIT_SEQUENCE_EDITOR":"true","GIT_PAGER":"cat","PAGER":"cat","npm_config_yes":"true","PIP_NO_INPUT":"1","YARN_ENABLE_IMMUTABLE_INSTALLS":"false"}},"tool_output":{"output":"=== RUN   Example_basic\n--- PASS: Example_basic (0.00s)\n=== RUN   Example_getOrSet\n--- PASS: Example_getOrSet (0.00s)\n=== RUN   Example_eviction\n--- PASS: Example_eviction (0.00s)\n=== RUN   Example_evictionCallback\n--- PASS: Example_evictionCallback (0.00s)\n=== RUN   Example_expirableBasic\n--- PASS: Example_expirableBasic (0.00s)\n=== RUN   Example_getWithTTL\n--- PASS: Example_getWithTTL (0.00s)\n=== RUN   Example_lruAndExpiration\n--- PASS: Example_lruAndExpiration (0.00s)\n=== RUN   Example_expirableEvictionCallback\n--- PASS: Example_expirableEvictionCallback (0.00s)\nPASS\nok  \tgithub.com/rselbach/lru\t0.943s\n","exit":0,"description":"Run example tests"}}
{"type":"tool_use","timestamp":"2025-12-29T19:47:04.904Z","tool_name":"lsp_diagnostics","tool_input":{"filePath":"/Users/rselbach/devel/lru/doc.go"}}
{"type":"tool_use","timestamp":"2025-12-29T19:47:05.254Z","tool_name":"lsp_diagnostics","tool_input":{"filePath":"/Users/rselbach/devel/lru/lru.go"}}
{"type":"tool_use","timestamp":"2025-12-29T19:47:05.571Z","tool_name":"lsp_diagnostics","tool_input":{"filePath":"/Users/rselbach/devel/lru/expirable.go"}}
{"type":"tool_result","timestamp":"2025-12-29T19:47:06.821Z","tool_name":"lsp_diagnostics","tool_input":{"filePath":"/Users/rselbach/devel/lru/lru.go"},"tool_output":{"output":"No diagnostics found"}}
{"type":"tool_result","timestamp":"2025-12-29T19:47:06.822Z","tool_name":"lsp_diagnostics","tool_input":{"filePath":"/Users/rselbach/devel/lru/doc.go"},"tool_output":{"output":"No diagnostics found"}}
{"type":"tool_result","timestamp":"2025-12-29T19:47:07.079Z","tool_name":"lsp_diagnostics","tool_input":{"filePath":"/Users/rselbach/devel/lru/expirable.go"},"tool_output":{"output":"No diagnostics found"}}
{"type":"user","timestamp":"2025-12-29T19:48:03.071Z","content":"good, now create a PR with the changes"}
{"type":"tool_use","timestamp":"2025-12-29T19:48:14.838Z","tool_name":"bash","tool_input":{"command":"cd /Users/rselbach/devel/lru && git status && echo \"---\" && git branch --show-current && echo \"---\" && git log --oneline -5","description":"Check git status, branch, and recent commits"}}
{"type":"tool_result","timestamp":"2025-12-29T19:48:14.893Z","tool_name":"bash","tool_input":{"command":"cd /Users/rselbach/devel/lru && git status && echo \"---\" && git branch --show-current && echo \"---\" && git log --oneline -5","description":"Check git status, branch, and recent commits","env":{"CI":"true","DEBIAN_FRONTEND":"noninteractive","GIT_TERMINAL_PROMPT":"0","GCM_INTERACTIVE":"never","HOMEBREW_NO_AUTO_UPDATE":"1","GIT_EDITOR":"true","EDITOR":"true","VISUAL":"true","GIT_SEQUENCE_EDITOR":"true","GIT_PAGER":"cat","PAGER":"cat","npm_config_yes":"true","PIP_NO_INPUT":"1","YARN_ENABLE_IMMUTABLE_INSTALLS":"false"}},"tool_output":{"output":"On branch main\nYour branch is up to date with 'origin/main'.\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   README.md\n\tmodified:   callbacks_test.go\n\tmodified:   expirable.go\n\tmodified:   lru.go\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\tdoc.go\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n---\nmain\n---\ne6a3106 fix: race condition in Expirable cache reads (#9)\nfc52ac8 fix: remove expired items on Get and call onEvict for all evictions (#8)\n178b3b1 fix: call onEvict outside lock in Expirable to prevent deadlock (#7)\n6a151b4 fix: call onEvict outside lock in Cache to prevent deadlock (#6)\n664a2c8 fix: call compute outside lock in Expirable.GetOrSet (#5)\n","exit":0,"description":"Check git status, branch, and recent commits"}}
{"type":"tool_use","timestamp":"2025-12-29T19:48:27.203Z","tool_name":"bash","tool_input":{"command":"cd /Users/rselbach/devel/lru && git checkout -b improve-docs && git add doc.go README.md callbacks_test.go expirable.go lru.go && git commit -m \"docs: improve godoc and slim down README\n\n- add doc.go with package overview and usage examples\n- document Expirable.Clear callback behavior for expired items\n- add nil check to SetTimeNowFunc (resets to time.Now)\n- remove duplicate package comments from lru.go and expirable.go\n- slim README to point to pkg.go.dev for full docs\"","description":"Create branch and commit changes","env":"{\"CI\": \"true\", \"DEBIAN_FRONTEND\": \"noninteractive\", \"GIT_TERMINAL_PROMPT\": \"0\", \"GCM_INTERACTIVE\": \"never\", \"HOMEBREW_NO_AUTO_UPDATE\": \"1\", \"GIT_EDITOR\": \"true\", \"EDITOR\": \"true\", \"VISUAL\": \"true\", \"GIT_SEQUENCE_EDITOR\": \"true\", \"GIT_PAGER\": \"cat\", \"PAGER\": \"cat\", \"npm_config_yes\": \"true\", \"PIP_NO_INPUT\": \"1\", \"YARN_ENABLE_IMMUTABLE_INSTALLS\": \"false\"}"}}
{"type":"tool_result","timestamp":"2025-12-29T19:48:27.440Z","tool_name":"bash","tool_input":{"command":"cd /Users/rselbach/devel/lru && git checkout -b improve-docs && git add doc.go README.md callbacks_test.go expirable.go lru.go && git commit -m \"docs: improve godoc and slim down README\n\n- add doc.go with package overview and usage examples\n- document Expirable.Clear callback behavior for expired items\n- add nil check to SetTimeNowFunc (resets to time.Now)\n- remove duplicate package comments from lru.go and expirable.go\n- slim README to point to pkg.go.dev for full docs\"","description":"Create branch and commit changes","env":{"0":"{","1":"\"","2":"C","3":"I","4":"\"","5":":","6":" ","7":"\"","8":"t","9":"r","10":"u","11":"e","12":"\"","13":",","14":" ","15":"\"","16":"D","17":"E","18":"B","19":"I","20":"A","21":"N","22":"_","23":"F","24":"R","25":"O","26":"N","27":"T","28":"E","29":"N","30":"D","31":"\"","32":":","33":" ","34":"\"","35":"n","36":"o","37":"n","38":"i","39":"n","40":"t","41":"e","42":"r","43":"a","44":"c","45":"t","46":"i","47":"v","48":"e","49":"\"","50":",","51":" ","52":"\"","53":"G","54":"I","55":"T","56":"_","57":"T","58":"E","59":"R","60":"M","61":"I","62":"N","63":"A","64":"L","65":"_","66":"P","67":"R","68":"O","69":"M","70":"P","71":"T","72":"\"","73":":","74":" ","75":"\"","76":"0","77":"\"","78":",","79":" ","80":"\"","81":"G","82":"C","83":"M","84":"_","85":"I","86":"N","87":"T","88":"E","89":"R","90":"A","91":"C","92":"T","93":"I","94":"V","95":"E","96":"\"","97":":","98":" ","99":"\"","100":"n","101":"e","102":"v","103":"e","104":"r","105":"\"","106":",","107":" ","108":"\"","109":"H","110":"O","111":"M","112":"E","113":"B","114":"R","115":"E","116":"W","117":"_","118":"N","119":"O","120":"_","121":"A","122":"U","123":"T","124":"O","125":"_","126":"U","127":"P","128":"D","129":"A","130":"T","131":"E","132":"\"","133":":","134":" ","135":"\"","136":"1","137":"\"","138":",","139":" ","140":"\"","141":"G","142":"I","143":"T","144":"_","145":"E","146":"D","147":"I","148":"T","149":"O","150":"R","151":"\"","152":":","153":" ","154":"\"","155":"t","156":"r","157":"u","158":"e","159":"\"","160":",","161":" ","162":"\"","163":"E","164":"D","165":"I","166":"T","167":"O","168":"R","169":"\"","170":":","171":" ","172":"\"","173":"t","174":"r","175":"u","176":"e","177":"\"","178":",","179":" ","180":"\"","181":"V","182":"I","183":"S","184":"U","185":"A","186":"L","187":"\"","188":":","189":" ","190":"\"","191":"t","192":"r","193":"u","194":"e","195":"\"","196":",","197":" ","198":"\"","199":"G","200":"I","201":"T","202":"_","203":"S","204":"E","205":"Q","206":"U","207":"E","208":"N","209":"C","210":"E","211":"_","212":"E","213":"D","214":"I","215":"T","216":"O","217":"R","218":"\"","219":":","220":" ","221":"\"","222":"t","223":"r","224":"u","225":"e","226":"\"","227":",","228":" ","229":"\"","230":"G","231":"I","232":"T","233":"_","234":"P","235":"A","236":"G","237":"E","238":"R","239":"\"","240":":","241":" ","242":"\"","243":"c","244":"a","245":"t","246":"\"","247":",","248":" ","249":"\"","250":"P","251":"A","252":"G","253":"E","254":"R","255":"\"","256":":","257":" ","258":"\"","259":"c","260":"a","261":"t","262":"\"","263":",","264":" ","265":"\"","266":"n","267":"p","268":"m","269":"_","270":"c","271":"o","272":"n","273":"f","274":"i","275":"g","276":"_","277":"y","278":"e","279":"s","280":"\"","281":":","282":" ","283":"\"","284":"t","285":"r","286":"u","287":"e","288":"\"","289":",","290":" ","291":"\"","292":"P","293":"I","294":"P","295":"_","296":"N","297":"O","298":"_","299":"I","300":"N","301":"P","302":"U","303":"T","304":"\"","305":":","306":" ","307":"\"","308":"1","309":"\"","310":",","311":" ","312":"\"","313":"Y","314":"A","315":"R","316":"N","317":"_","318":"E","319":"N","320":"A","321":"B","322":"L","323":"E","324":"_","325":"I","326":"M","327":"M","328":"U","329":"T","330":"A","331":"B","332":"L","333":"E","334":"_","335":"I","336":"N","337":"S","338":"T","339":"A","340":"L","341":"L","342":"S","343":"\"","344":":","345":" ","346":"\"","347":"f","348":"a","349":"l","350":"s","351":"e","352":"\"","353":"}","CI":"true","DEBIAN_FRONTEND":"noninteractive","GIT_TERMINAL_PROMPT":"0","GCM_INTERACTIVE":"never","HOMEBREW_NO_AUTO_UPDATE":"1","GIT_EDITOR":"true","EDITOR":"true","VISUAL":"true","GIT_SEQUENCE_EDITOR":"true","GIT_PAGER":"cat","PAGER":"cat","npm_config_yes":"true","PIP_NO_INPUT":"1","YARN_ENABLE_IMMUTABLE_INSTALLS":"false"}},"tool_output":{"output":"Switched to a new branch 'improve-docs'\n[improve-docs 172f77a] docs: improve godoc and slim down README\n 5 files changed, 80 insertions(+), 238 deletions(-)\n create mode 100644 doc.go\n","exit":0,"description":"Create branch and commit changes"}}
{"type":"tool_use","timestamp":"2025-12-29T19:48:38.855Z","tool_name":"bash","tool_input":{"command":"cd /Users/rselbach/devel/lru && git push -u origin improve-docs && gh pr create --title \"docs: improve godoc and slim down README\" --body \"$(cat <<'EOF'\n## Summary\n\n- Add `doc.go` with package overview and usage examples for godoc\n- Document `Expirable.Clear` callback behavior (only invokes for non-expired entries)\n- Add nil check to `SetTimeNowFunc` (passing nil resets to `time.Now`)\n- Remove duplicate package comments from source files\n- Slim down README to essentials, point to pkg.go.dev for full docs\n\nAll existing examples in `example_test.go` and `expirable_example_test.go` now serve as the canonical documentation examples.\nEOF\n)\"","description":"Push branch and create PR","env":"{\"CI\": \"true\", \"DEBIAN_FRONTEND\": \"noninteractive\", \"GIT_TERMINAL_PROMPT\": \"0\", \"GCM_INTERACTIVE\": \"never\", \"HOMEBREW_NO_AUTO_UPDATE\": \"1\", \"GIT_EDITOR\": \"true\", \"EDITOR\": \"true\", \"VISUAL\": \"true\", \"GIT_SEQUENCE_EDITOR\": \"true\", \"GIT_PAGER\": \"cat\", \"PAGER\": \"cat\", \"npm_config_yes\": \"true\", \"PIP_NO_INPUT\": \"1\", \"YARN_ENABLE_IMMUTABLE_INSTALLS\": \"false\"}"}}
{"type":"tool_result","timestamp":"2025-12-29T19:48:46.325Z","tool_name":"bash","tool_input":{"command":"cd /Users/rselbach/devel/lru && git push -u origin improve-docs && gh pr create --title \"docs: improve godoc and slim down README\" --body \"$(cat <<'EOF'\n## Summary\n\n- Add `doc.go` with package overview and usage examples for godoc\n- Document `Expirable.Clear` callback behavior (only invokes for non-expired entries)\n- Add nil check to `SetTimeNowFunc` (passing nil resets to `time.Now`)\n- Remove duplicate package comments from source files\n- Slim down README to essentials, point to pkg.go.dev for full docs\n\nAll existing examples in `example_test.go` and `expirable_example_test.go` now serve as the canonical documentation examples.\nEOF\n)\"","description":"Push branch and create PR","env":{"0":"{","1":"\"","2":"C","3":"I","4":"\"","5":":","6":" ","7":"\"","8":"t","9":"r","10":"u","11":"e","12":"\"","13":",","14":" ","15":"\"","16":"D","17":"E","18":"B","19":"I","20":"A","21":"N","22":"_","23":"F","24":"R","25":"O","26":"N","27":"T","28":"E","29":"N","30":"D","31":"\"","32":":","33":" ","34":"\"","35":"n","36":"o","37":"n","38":"i","39":"n","40":"t","41":"e","42":"r","43":"a","44":"c","45":"t","46":"i","47":"v","48":"e","49":"\"","50":",","51":" ","52":"\"","53":"G","54":"I","55":"T","56":"_","57":"T","58":"E","59":"R","60":"M","61":"I","62":"N","63":"A","64":"L","65":"_","66":"P","67":"R","68":"O","69":"M","70":"P","71":"T","72":"\"","73":":","74":" ","75":"\"","76":"0","77":"\"","78":",","79":" ","80":"\"","81":"G","82":"C","83":"M","84":"_","85":"I","86":"N","87":"T","88":"E","89":"R","90":"A","91":"C","92":"T","93":"I","94":"V","95":"E","96":"\"","97":":","98":" ","99":"\"","100":"n","101":"e","102":"v","103":"e","104":"r","105":"\"","106":",","107":" ","108":"\"","109":"H","110":"O","111":"M","112":"E","113":"B","114":"R","115":"E","116":"W","117":"_","118":"N","119":"O","120":"_","121":"A","122":"U","123":"T","124":"O","125":"_","126":"U","127":"P","128":"D","129":"A","130":"T","131":"E","132":"\"","133":":","134":" ","135":"\"","136":"1","137":"\"","138":",","139":" ","140":"\"","141":"G","142":"I","143":"T","144":"_","145":"E","146":"D","147":"I","148":"T","149":"O","150":"R","151":"\"","152":":","153":" ","154":"\"","155":"t","156":"r","157":"u","158":"e","159":"\"","160":",","161":" ","162":"\"","163":"E","164":"D","165":"I","166":"T","167":"O","168":"R","169":"\"","170":":","171":" ","172":"\"","173":"t","174":"r","175":"u","176":"e","177":"\"","178":",","179":" ","180":"\"","181":"V","182":"I","183":"S","184":"U","185":"A","186":"L","187":"\"","188":":","189":" ","190":"\"","191":"t","192":"r","193":"u","194":"e","195":"\"","196":",","197":" ","198":"\"","199":"G","200":"I","201":"T","202":"_","203":"S","204":"E","205":"Q","206":"U","207":"E","208":"N","209":"C","210":"E","211":"_","212":"E","213":"D","214":"I","215":"T","216":"O","217":"R","218":"\"","219":":","220":" ","221":"\"","222":"t","223":"r","224":"u","225":"e","226":"\"","227":",","228":" ","229":"\"","230":"G","231":"I","232":"T","233":"_","234":"P","235":"A","236":"G","237":"E","238":"R","239":"\"","240":":","241":" ","242":"\"","243":"c","244":"a","245":"t","246":"\"","247":",","248":" ","249":"\"","250":"P","251":"A","252":"G","253":"E","254":"R","255":"\"","256":":","257":" ","258":"\"","259":"c","260":"a","261":"t","262":"\"","263":",","264":" ","265":"\"","266":"n","267":"p","268":"m","269":"_","270":"c","271":"o","272":"n","273":"f","274":"i","275":"g","276":"_","277":"y","278":"e","279":"s","280":"\"","281":":","282":" ","283":"\"","284":"t","285":"r","286":"u","287":"e","288":"\"","289":",","290":" ","291":"\"","292":"P","293":"I","294":"P","295":"_","296":"N","297":"O","298":"_","299":"I","300":"N","301":"P","302":"U","303":"T","304":"\"","305":":","306":" ","307":"\"","308":"1","309":"\"","310":",","311":" ","312":"\"","313":"Y","314":"A","315":"R","316":"N","317":"_","318":"E","319":"N","320":"A","321":"B","322":"L","323":"E","324":"_","325":"I","326":"M","327":"M","328":"U","329":"T","330":"A","331":"B","332":"L","333":"E","334":"_","335":"I","336":"N","337":"S","338":"T","339":"A","340":"L","341":"L","342":"S","343":"\"","344":":","345":" ","346":"\"","347":"f","348":"a","349":"l","350":"s","351":"e","352":"\"","353":"}","CI":"true","DEBIAN_FRONTEND":"noninteractive","GIT_TERMINAL_PROMPT":"0","GCM_INTERACTIVE":"never","HOMEBREW_NO_AUTO_UPDATE":"1","GIT_EDITOR":"true","EDITOR":"true","VISUAL":"true","GIT_SEQUENCE_EDITOR":"true","GIT_PAGER":"cat","PAGER":"cat","npm_config_yes":"true","PIP_NO_INPUT":"1","YARN_ENABLE_IMMUTABLE_INSTALLS":"false"}},"tool_output":{"output":"remote: \nremote: Create a pull request for 'improve-docs' on GitHub by visiting:        \nremote:      https://github.com/rselbach/lru/pull/new/improve-docs        \nremote: \nTo github.com:rselbach/lru.git\n * [new branch]      improve-docs -> improve-docs\nbranch 'improve-docs' set up to track 'origin/improve-docs'.\nhttps://github.com/rselbach/lru/pull/10\n","exit":0,"description":"Push branch and create PR"}}
